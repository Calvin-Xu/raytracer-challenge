#+STARTUP: show2levels
#+TITLE:     The Ray Tracer Challenge Notes
#+AUTHOR:    Calvin Xu
#+EMAIL:     calvinxu806@gmail.com

#+begin_quote
Admittedly, the explanations do tend toward imperative, procedural, and object-oriented languages, but the concepts and tests themselves are translatable to any environment you wish.
#+end_quote

My implementation will be in Typed Racket with unit tests in RackUnit. I will not be using OOP features in ~typed/racket/class~ as they are still "experimental". Usage of libraries will be minimal. Low-hanging optimization gains are done, but otherwise this is a learning project.

* DONE Tuples, Points, and Vectors
:PROPERTIES:
:ACTIVATED: [2022-07-30]
:END:
** DONE Tuples
:PROPERTIES:
:ACTIVATED: [2022-07-30]
:END:
Left-handed coordinate system (+x right, +y up, +z away)

Note that Typed Racket currently does not support ~field-option~ in structs meaning we can't set ~w~ to ~#:auto~ to prepopulate values.

Since the book hints at some runtime checks/tricks in the way it defined points and vectors, ~pt?~ and ~vec?~ are currently implemented this way.

The constructors that accept ~Real~ are written so that Typed Racket accepts numbers without the decimal point in the source code for the tests...

#+NAME: tuple-base
#+BEGIN_SRC racket :noweb yes
(struct tuple ([x : Float] [y : Float] [z : Float] [w : Float]) #:prefab #:type-name Tuple)
(struct point tuple () #:prefab #:type-name Point)
(struct vect tuple () #:prefab #:type-name Vector)

(: pt (->* (Float Float Float) (Float) Point))
(define (pt x y z [w 1.])
  (point x y z w))

(: pt? (-> Tuple Boolean))
(define (pt? t)
  (= (tuple-w t) 1.))

(: vec (->* (Float Float Float) (Float) Vector))
(define (vec x y z [w 0.])
  (vect x y z w))

(: vec? (-> Tuple Boolean))
(define (vec? t)
  (= (tuple-w t) 0.))

(: adaptive-tuple (-> Float Float Float Float Tuple))
(define (adaptive-tuple x y z w)
  (cond
    [(= w 1) (pt x y z)]
    [(= w 0) (vec x y z)]
    [else (tuple x y z w)]))
#+END_SRC

We can compare floats in ~rackunit~ with [[https://docs.racket-lang.org/rackunit/api.html#(def._((lib._rackunit/main..rkt)._check-~3d))][(check-= v1 v2 epsilon)]]:

#+begin_example
(check-= 1.0 1.01 0.02 "I work")
(check-= 1.0 1.01 0.005 "I fail")
#+end_example

In case I need it outside of tests:

#+NAME: f=
#+BEGIN_SRC racket :noweb yes
(: f= (-> Float Float Boolean))
(define (f= a b)
  (: EPSILON Float)
  (define EPSILON 0.00001)
  (< (abs (- a b)) EPSILON))
#+END_SRC

We should already be able to compare tuples for equality by making them ~#:prefab~. But then that isn't going to cut it. RackUnit's ~define-check~ seems broken in Typed Racket...I can't get a trivial example to work in the REPL and I can't find anyone's usage online. My own macro it is:

#+NAME: check-tuple=
#+BEGIN_SRC racket :noweb yes
(define-syntax-rule (check-tuple= t1 t2)
  (unless (and (f= (tuple-x t1) (tuple-x t2))
               (f= (tuple-y t1) (tuple-y t2))
               (f= (tuple-z t1) (tuple-z t2))
               (f= (tuple-w t1) (tuple-w t2)))
    (printf "Failure: tuples not equal ~v, ~v\n" t1 t2)))
#+END_SRC

** DONE Operations
:PROPERTIES:
:ACTIVATED: [2022-07-30]
:END:
*** Addition
- point + point -> ?
- point + vector -> point
- vector + point -> point
- vector + vector -> vector

#+NAME: tuple+
#+BEGIN_SRC racket :noweb yes
(: tuple+ (-> Tuple Tuple Tuple))
(define (tuple+ t1 t2)
  (let* ([xyzw : (List Float Float Float Float)
          (list (+ (tuple-x t1) (tuple-x t2))
                (+ (tuple-y t1) (tuple-y t2))
                (+ (tuple-z t1) (tuple-z t2))
                (+ (tuple-w t1) (tuple-w t2)))]
         [xyz : (List Float Float Float)
          (reverse (cdr (reverse xyzw)))])

    (cond
      [(and (pt? t1) (pt? t2) (error "Illegal operation: point + point" t1 t2))]
      [(or (and (pt? t1) (vec? t2)) (and (pt? t2) (vec? t1))) (apply pt xyz)]
      [(and (vec? t1) (vec? t2)) (apply vec xyz)]
      [else (apply tuple xyzw)])))
#+END_SRC

Let's make a variadic version:

#+BEGIN_SRC racket :noweb yes
(: tuples+ (-> Tuple * Tuple))
(define (tuples+ . tuples)
  (let loop ([sum (car tuples)] [args (cdr tuples)])
    (if (null? args) sum (loop (tuple+ sum (car args)) (cdr args)))))
#+END_SRC

...SICPish; or maybe try:

#+NAME: tuples+
#+BEGIN_SRC racket :noweb yes
(: tuples+ (-> Tuple * Tuple))
(define (tuples+ . tuples)
  (foldl tuple+ (tuple 0. 0. 0. 0.) tuples))
#+END_SRC

*** Subtraction
- point - point -> vector
- point - vector -> point
- vector - point -> ?
- vector - vector -> vector

#+NAME: tuple-
#+BEGIN_SRC racket :noweb yes
(: tuple- (-> Tuple Tuple Tuple))
(define (tuple- t1 t2)
  (let* ([xyzw : (List Float Float Float Float)
          (list (- (tuple-x t1) (tuple-x t2))
                (- (tuple-y t1) (tuple-y t2))
                (- (tuple-z t1) (tuple-z t2))
                (- (tuple-w t1) (tuple-w t2)))]
         [xyz : (List Float Float Float)
          (reverse (cdr (reverse xyzw)))])

    (cond
      [(and (vec? t1) (pt? t2) (error "Illegal operation: vector - point" t1 t2))]
      [(and (pt? t1) (pt? t2)) (apply vec xyz)]
      [(and (vec? t1) (vec? t2)) (apply vec xyz)]
      [(and (pt? t1) (vec? t2)) (apply pt xyz)]
      [else (apply tuple xyzw)])))
#+END_SRC

#+NAME: tuples-
#+BEGIN_SRC racket :noweb yes
(: tuples- (-> Tuple * Tuple))
(define (tuples- . tuples)
  ;; optimization when the list is known non-empty
  (if (null? tuples)
      (error "Illegal operation: no arguments provided")
      (foldl tuple+ (car tuples) (map -tuple (cdr tuples)))))
#+END_SRC

*** Negation
#+NAME: -tuple
#+BEGIN_SRC racket :noweb yes
(: -tuple (-> Tuple Tuple))
(define (-tuple t)
  (adaptive-tuple (- (tuple-x t)) (- (tuple-y t)) (- (tuple-z t)) (- (tuple-w t))))
#+END_SRC

*** Scalar Multiplication and Division
#+NAME: tuple*
#+BEGIN_SRC racket :noweb yes
(: tuple* (-> Tuple Float Tuple))
(define (tuple* t s)
  (adaptive-tuple (* (tuple-x t) s) (* (tuple-y t) s) (* (tuple-z t) s) (* (tuple-w t) s)))
#+END_SRC

#+NAME: tuple/
#+BEGIN_SRC racket :noweb yes
(: tuple/ (-> Tuple Float Tuple))
(define (tuple/ t s)
  (adaptive-tuple (/ (tuple-x t) s) (/ (tuple-y t) s) (/ (tuple-z t) s) (/ (tuple-w t) s)))
#+END_SRC

*** Magnitude
#+NAME: mag
#+BEGIN_SRC racket :noweb yes
(: mag (-> Vector Float))
(define (mag v)
  (sqrt (+ (sqr (tuple-x v)) (sqr (tuple-y v)) (sqr (tuple-z v)))))
#+END_SRC

*** Normalization
#+NAME: norm
#+BEGIN_SRC racket :noweb yes
(: norm (-> Vector Vector))
(define (norm v)
  (let ([mag : Float (mag v)])
    (vec (/ (tuple-x v) mag) (/ (tuple-y v) mag) (/ (tuple-z v) mag))))
#+END_SRC

*** Dot Product
#+NAME: dot*
#+BEGIN_SRC racket :noweb yes
(: dot* (-> Vector Vector Float))
(define (dot* v1 v2)
  (+ (* (tuple-x v1) (tuple-x v2))
     (* (tuple-y v1) (tuple-y v2))
     (* (tuple-z v1) (tuple-z v2))
     (* (tuple-w v1) (tuple-w v2))))
#+END_SRC

*** Cross Product
#+NAME: cross*
#+BEGIN_SRC racket :noweb yes
(: cross* (-> Vector Vector Vector))
(define (cross* v1 v2)
  (vec (- (* (tuple-y v1) (tuple-z v2)) (* (tuple-z v1) (tuple-y v2)))
       (- (* (tuple-z v1) (tuple-x v2)) (* (tuple-x v1) (tuple-z v2)))
       (- (* (tuple-x v1) (tuple-y v2)) (* (tuple-y v1) (tuple-x v2)))))
#+END_SRC

** DONE Putting It Together
:PROPERTIES:
:ACTIVATED: [2022-07-31]
:END:
A fun playground:

#+BEGIN_SRC racket :noweb yes
<<tuples>>

(struct projectile ([position : Tuple] [velocity : Tuple]) #:prefab)
(struct environment ([gravity : Tuple] [wind : Tuple]) #:prefab)

(: tick (-> environment projectile projectile))
(define (tick env proj)
  (projectile (tuple+ (projectile-position proj) (projectile-velocity proj))
              (tuples+ (projectile-velocity proj) (environment-gravity env) (environment-wind env))))

(define p (projectile (pt 0. 1. 0.) (norm (vec 1. 1. 0.))))
(define e (environment (vec 0. -0.1 0.) (vec -0.01 0. 0.)))

(: iter (-> environment projectile Integer Any))
(define (iter env proj n)
  (if (or (> n 100) (<= (tuple-y (projectile-position proj)) 0))
      (print "Hit ground")
      (begin
        (printf "Tick #~v\n" n)
        (printf "Position: ~v\n" (projectile-position proj))
        (iter e (tick e proj) (+ 1 n)))))

(iter e p 0)
#+END_SRC

#+RESULTS:
#+begin_example
Tick #0
Position: '#s((point tuple 4) 0.0 1.0 0.0 1.0)
Tick #1
Position: '#s((point tuple 4) 0.7071067811865475 1.7071067811865475 0.0 1.0)
Tick #2
Position: '#s((point tuple 4) 1.404213562373095 2.314213562373095 0.0 1.0)
Tick #3
Position: '#s((point tuple 4) 2.0913203435596426 2.821320343559642 0.0 1.0)
Tick #4
Position: '#s((point tuple 4) 2.7684271247461902 3.2284271247461898 0.0 1.0)
Tick #5
Position: '#s((point tuple 4) 3.4355339059327377 3.5355339059327373 0.0 1.0)
Tick #6
Position: '#s((point tuple 4) 4.092640687119285 3.7426406871192848 0.0 1.0)
Tick #7
Position: '#s((point tuple 4) 4.739747468305833 3.849747468305832 0.0 1.0)
Tick #8
Position: '#s((point tuple 4) 5.37685424949238 3.85685424949238 0.0 1.0)
Tick #9
Position: '#s((point tuple 4) 6.003961030678928 3.7639610306789275 0.0 1.0)
Tick #10
Position: '#s((point tuple 4) 6.621067811865475 3.571067811865475 0.0 1.0)
Tick #11
Position: '#s((point tuple 4) 7.228174593052023 3.2781745930520225 0.0 1.0)
Tick #12
Position: '#s((point tuple 4) 7.82528137423857 2.88528137423857 0.0 1.0)
Tick #13
Position: '#s((point tuple 4) 8.412388155425118 2.3923881554251176 0.0 1.0)
Tick #14
Position: '#s((point tuple 4) 8.989494936611665 1.7994949366116653 0.0 1.0)
Tick #15
Position: '#s((point tuple 4) 9.556601717798213 1.1066017177982128 0.0 1.0)
Tick #16
Position: '#s((point tuple 4) 10.11370849898476 0.3137084989847604 0.0 1.0)
"Hit ground"
#+end_example

#+NAME: tuples
#+BEGIN_SRC racket :noweb yes :tangle tuples.rkt
#lang typed/racket
(provide (all-defined-out))

<<tuple-base>>

<<f=>>

<<tuple+>>

<<tuples+>>

<<tuple->>

<<tuples->>

<<-tuple>>

<<tuple*>>

<<tuple/>>

<<mag>>

<<norm>>

<<dot*>>

<<cross*>>
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/tuples-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt")

(define-syntax-rule (check-tuple= t1 t2)
  (unless (and (f= (tuple-x t1) (tuple-x t2))
               (f= (tuple-y t1) (tuple-y t2))
               (f= (tuple-z t1) (tuple-z t2))
               (f= (tuple-w t1) (tuple-w t2)))
    (printf "Failure: tuples not equal ~v, ~v\n" t1 t2)))

(define tuples-test
  (test-suite
   "Tuples, Points, and Vectors"
   (test-case "tuple-base"
              (define a (tuple 4.3 -4.2 3.1 1.0))
              (check-equal? (tuple-x a) 4.3)
              (check-equal? (tuple-y a) -4.2)
              (check-equal? (tuple-z a) 3.1)
              (check-equal? (tuple-w a) 1.0)
              (check-true (pt? a))
              (check-false (vec? a))
              (define b (tuple 4.3 -4.2 3.1 0.0))
              (check-equal? (tuple-x b) 4.3)
              (check-equal? (tuple-y b) -4.2)
              (check-equal? (tuple-z b) 3.1)
              (check-equal? (tuple-w b) 0.0)
              (check-false (pt? b))
              (check-true (vec? b))
              (define c (pt 4. -4. 3.))
              (check-tuple= c (tuple 4. -4. 3. 1.))
              (define d (vec 4. -4. 3.))
              (check-tuple= d (tuple 4. -4. 3. 0.)))
   (test-case "addition"
              (check-tuple= (tuple+ (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.)) (tuple 1. 1. 6. 1.))
              (check-tuple= (tuples+ (tuple 3. -2. 5. 1.)) (tuple 3. -2. 5. 1.))
              (check-tuple= (tuples+ (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.)) (tuple 1. 1. 6. 1.))
              (check-tuple= (tuples+ (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.) (tuple 1. 1. 1. 0.))
                            (tuple 2. 2. 7. 1.)))
   (test-case "subtraction"
              (check-tuple= (tuple- (pt 3. 2. 1.) (pt 5. 6. 7.)) (vec -2. -4. -6.))
              (check-tuple= (tuples- (tuple 3. -2. 5. 1.)) (tuple 3. -2. 5. 1.))
              (check-tuple= (tuples- (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.)) (tuple 5. -5. 4. 1.))
              (check-tuple= (tuples- (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.) (tuple 1. 1. 1. 1.))
                            (tuple 4. -6. 3. 0.)))
   (test-case "negation"
              (check-tuple= (tuple- (vec 0. 0. 0.) (vec 1. -2. 3.)) (vec -1. 2. -3.))
              (check-tuple= (-tuple (tuple 1. -2. 3. -4.)) (tuple -1. 2. -3. 4.)))
   (test-case "multiplication and division"
              (define a (tuple 1. -2. 3. -4.))
              (check-tuple= (tuple* a 3.5) (tuple 3.5 -7.0 10.5 -14.0))
              (check-tuple= (tuple* a 0.5) (tuple 0.5 -1.0 1.5 -2.0))
              (check-tuple= (tuple/ (tuple 1.0 -2. 3.0 -4.) 2.) (tuple 0.5 -1. 1.5 -2.)))
   (test-case "magnitude"
              (check-= (mag (vec 1. 0. 0.)) 1. 0.00001)
              (check-= (mag (vec 0. 1. 0.)) 1. 0.00001)
              (check-= (mag (vec 0. 0. 1.)) 1. 0.00001)
              (check-= (mag (vec 1. 2. 3.)) (sqrt 14.) 0.00001)
              (check-= (mag (vec -1. -2. -3.)) (sqrt 14.) 0.00001))
   (test-case "normalization"
              (check-tuple= (norm (vec 4. 0. 0.)) (vec 1. 0. 0.))
              (check-tuple= (norm (vec 1. 2. 3.)) (vec 0.26726 0.53452 0.80178)))
   (test-case "dot product" (check-= (dot* (vec 1. 2. 3.) (vec 2. 3. 4.)) 20. 0.00001))
   (test-case "cross product"
              (check-tuple= (cross* (vec 1. 2. 3.) (vec 2. 3. 4.)) (vec -1. 2. -1.))
              (check-tuple= (cross* (vec 2. 3. 4.) (vec 1. 2. 3.)) (vec 1. -2. 1.)))))

(run-tests tuples-test)
#+END_SRC

* DONE Drawing on a Canvas
:PROPERTIES:
:ACTIVATED: [2022-08-02]
:END:
** DONE Representing Colors
#+NAME: color-base
#+BEGIN_SRC racket :noweb yes
(struct color ([r : Float] [g : Float] [b : Float]) #:prefab #:type-name Color)

(: color->string (->* (Color) (Exact-Nonnegative-Integer) String))
(define (color->string color [max_color_val 255])
  (: scale (-> Float Integer))
  (define (scale frac)
    (exact-round (cast (* (max 0 (min 1.0 frac)) max_color_val) Float)))
  (string-append (number->string (scale (color-r color)))
                 " "
                 (number->string (scale (color-g color)))
                 " "
                 (number->string (scale (color-b color)))
                 " "))
#+END_SRC

#+NAME: check-color=
#+BEGIN_SRC racket :noweb yes
(define-syntax-rule (check-color= c1 c2)
  (unless (and (f= (color-r c1) (color-r c2))
               (f= (color-g c1) (color-g c2))
               (f= (color-b c1) (color-b c2)))
    (printf "Failure: colors not equal ~v, ~v\n" c1 c2)))
#+END_SRC

** DONE Implementing Color Operations
I'd rather not reuse the tuple implementations...
#+NAME: color-ops
#+BEGIN_SRC racket :noweb yes
(: color-op (-> (-> Float Float * Float) Color Color Color))
(define (color-op op c1 c2)
  (color (op (color-r c1) (color-r c2))
         (op (color-g c1) (color-g c2))
         (op (color-b c1) (color-b c2))))

(: color+ (-> Color Color Color))
(define (color+ c1 c2)
  (color-op + c1 c2))

(: color- (-> Color Color Color))
(define (color- c1 c2)
  (color-op - c1 c2))

(: color* (-> Color (U Color Float) Color))
(define (color* c arg)
  (color-op * c (if (color? arg) arg (color arg arg arg))))
#+END_SRC

** DONE Creating a Canvas
I got very tempted by  ~math/array~, but it might be more educational to build my own:

#+NAME: canvas-base
#+BEGIN_SRC racket :noweb yes
(struct _canvas
  ([width : Exact-Positive-Integer]
   [height : Exact-Positive-Integer]
   [pixels : (Mutable-Vectorof Color)]) #:prefab #:type-name Canvas)

(: canvas-width (-> Canvas Exact-Positive-Integer))
(define (canvas-width canvas)
  (_canvas-width canvas))

(: canvas-height (-> Canvas Exact-Positive-Integer))
(define (canvas-height canvas)
  (_canvas-height canvas))

(: canvas-pixels (-> Canvas (Mutable-Vectorof Color)))
(define (canvas-pixels canvas)
  (_canvas-pixels canvas))

(: canvas (-> Exact-Positive-Integer Exact-Positive-Integer Canvas))
(define (canvas width height)
  (_canvas width height (make-vector (* width height) (color 0. 0. 0.))))

(: pixel-at (-> Canvas Exact-Nonnegative-Integer Exact-Nonnegative-Integer Color))
(define (pixel-at canvas x y)
  (if (or (>= x (canvas-width canvas)) (>= y (canvas-height canvas)))
      (error "Illegal operation: access pixel out of bounds" x y)
      (vector-ref (canvas-pixels canvas) (+ (* y (canvas-width canvas)) x))))

(: set-pixel! (-> Canvas Exact-Nonnegative-Integer Exact-Nonnegative-Integer Color Void))
(define (set-pixel! canvas x y color)
  (if (or (>= x (canvas-width canvas)) (>= y (canvas-height canvas)))
      (error "Illegal operation: set pixel out of bounds" x y)
      (vector-set! (canvas-pixels canvas) (+ (* y (canvas-width canvas)) x) color)))
#+END_SRC

** DONE Saving a Canvas
PPM format specs: http://netpbm.sourceforge.net/doc/ppm.html

The following is very bad because I couldn't figure out a functional way of doing this.

#+NAME: canvas-save
#+BEGIN_SRC racket :noweb yes
(: serialize-canvas (->* (Canvas) (Exact-Nonnegative-Integer) String))
(define (serialize-canvas canvas [max_color_val 255])
  (define header
    (string-append "P3\n"
                   (number->string (canvas-width canvas))
                   " "
                   (number->string (canvas-height canvas))
                   "\n"
                   (number->string max_color_val)
                   "\n"))
  (define bitmap (vector-map (lambda ([x : Color]) (color->string x max_color_val)) (canvas-pixels canvas)))
  ;; color->string always adds whitespace at end
  ;; replace appropriate whitespaces with newlines
  (begin
    (let ([PIXELS_PER_ROW 6] [n (* (canvas-width canvas) (canvas-height canvas))])
      (for ([i (in-range n)])
        (when (or (= (add1 i) n) (= 0 (remainder (add1 i) PIXELS_PER_ROW)))
          (let ([curr (vector-ref bitmap i)])
            (vector-set! bitmap
                         i
                         (string-append (substring curr 0 (sub1 (string-length curr))) "\n"))))))
    (string-append header (string-append* (vector->list bitmap)))))

(: save-canvas (-> Canvas String Void))
(define (save-canvas canvas filename)
  (let ([out (open-output-file filename #:mode 'text #:exists 'replace)])
    (display (serialize-canvas canvas) out)
    (close-output-port out)))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
<<tuple-base>>
<<color-base>>
<<color-ops>>
<<canvas-base>>
<<canvas-save>>

(define c (canvas 5 3))
(set-pixel! c 0 0 (color 1.5 0 0))
(set-pixel! c 2 1 (color 0 0.5 0))
(set-pixel! c 4 2 (color -0.5 0 1))

(serialize-canvas c)
(save-canvas c "test.ppm")
#+END_SRC

#+RESULTS:
: "P3\n5 3\n255\n255 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 255\n"

** DONE Putting It Together
#+BEGIN_SRC racket :noweb yes
<<tuples>>
<<color-base>>
<<color-ops>>
<<canvas-base>>
<<canvas-save>>

(struct projectile ([position : Tuple] [velocity : Tuple]) #:prefab)
(struct environment ([gravity : Tuple] [wind : Tuple]) #:prefab)

(: tick (-> environment projectile projectile))
(define (tick env proj)
  (projectile (tuple+ (projectile-position proj) (projectile-velocity proj))
              (tuples+ (projectile-velocity proj) (environment-gravity env) (environment-wind env))))

(define p (projectile (pt 0. 1. 0.) (tuple* (norm (vec 1. 1.8 0.)) 11.25)))
(define e (environment (vec 0. -0.1 0.) (vec -0.01 0. 0.)))
(define c (canvas 900 550))

(: iter (-> environment projectile Canvas Integer Any))
(define (iter env proj canvas n)
  (if (or (> n 200) (<= (tuple-y (projectile-position proj)) 0))
      (begin
        (print "Hit ground")
        (save-canvas canvas "test.ppm"))
      (begin
        (printf "Tick #~v\n" n)
        (let ([position (projectile-position proj)]
              [flip (lambda ([y : Integer]) (- (canvas-height canvas) y))])
          (printf "Position: ~v\n" position)
          (set-pixel! canvas
                      (assert (max 0 (exact-round (tuple-x position))) nonnegative-integer?)
                      (assert (max 0 (flip (exact-round (tuple-y position)))) nonnegative-integer?)
                      (color 1. 0. 0.)))
        (iter e (tick e proj) canvas (+ 1 n)))))

(iter e p c 0)
#+END_SRC

#+NAME: canvas
#+BEGIN_SRC racket :noweb yes :tangle canvas.rkt
#lang typed/racket
(provide (except-out (all-defined-out) color-op))
(require "tuples.rkt")

<<color-base>>

<<check-color=>>

<<color-ops>>

<<canvas-base>>

<<canvas-save>>
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/canvas-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../canvas.rkt")

<<check-tuple=>>

(define canvas-test
  (test-suite
   "Drawing on a Canvas"
   (test-case "define color"
              (define c (color -0.5 0.4 1.7))
              (check-equal? (color-r c) -0.5)
              (check-equal? (color-g c) 0.4)
              (check-equal? (color-b c) 1.7))
   (test-case "add color"
              (define c1 (color 0.9 0.6 0.75))
              (define c2 (color 0.7 0.1 0.25))
              (check-color= (color+ c1 c2) (color 1.6 0.7 1.0)))
   (test-case "subtract color"
              (define c1 (color 0.9 0.6 0.75))
              (define c2 (color 0.7 0.1 0.25))
              (check-color= (color- c1 c2) (color 0.2 0.5 0.5)))
   (test-case "multiply color"
              (define c (color 0.2 0.3 0.4))
              (check-color= (color* c 2.) (color 0.4 0.6 0.8))
              (define c1 (color 1. 0.2 0.4))
              (define c2 (color 0.9 1. 0.1))
              (check-color= (color* c1 c2) (color 0.9 0.2 0.04)))
   (test-case "color to string"
              (define c (color 0.2 0.3 0.4))
              (check-equal? (color->string c) "51 76 102 "))
   (test-case "create and access canvas"
              (define c (canvas 10 20))
              (check-equal? (canvas-width c) 10)
              (check-equal? (canvas-height c) 20)
              (define red (color 1. 0. 0.))
              (set-pixel! c 2 3 red)
              (check-equal? (pixel-at c 2 3) red))
   (test-case
    "save canvas to ppm file"
    (define c (canvas 5 3))
    (set-pixel! c 0 0 (color 1.5 0. 0.))
    (set-pixel! c 2 1 (color 0. 0.5 0.))
    (set-pixel! c 4 2 (color -0.5 0. 1.))
    (check-equal?
     (serialize-canvas c)
     "P3\n5 3\n255\n255 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 255\n"))))

(run-tests canvas-test)
#+END_SRC

* DONE Matrices
:PROPERTIES:
:ACTIVATED: [2022-08-05]
:END:
** DONE Creating a Matrix
It might be a good idea to use ~FlVector~, but I still want to try multidimensional vectors...

#+NAME: matrix-base
#+BEGIN_SRC racket :noweb yes
(define-type Matrix (Immutable-Vectorof (Immutable-Vectorof Float)))

(: mat
   (-> Exact-Nonnegative-Integer
       Exact-Nonnegative-Integer
       (Immutable-Vectorof (Immutable-Vectorof Float))
       Matrix))
(define (mat m n rows)
  (if (and (= m (vector-length rows))
           (andmap (lambda ([x : Integer]) (= x n)) (vector->list (vector-map vector-length rows))))
      rows
      (error "Illegal operation: input not m by n 2D immutable vector" rows)))

(: mat-m (-> Matrix Exact-Nonnegative-Integer))
(define (mat-m mat)
  (vector-length mat))

(: mat-n (-> Matrix Exact-Nonnegative-Integer))
(define (mat-n mat)
  (vector-length (vector-ref mat 0)))

(: mat-entry (-> Matrix Exact-Nonnegative-Integer Exact-Nonnegative-Integer Float))
(define (mat-entry mat m n)
  (if (or (>= m (mat-m mat)) (>= n (mat-n mat)))
      (error "Illegal operation: access matrix element out of bounds")
      (vector-ref (vector-ref mat m) n)))

(: mat-row (-> Matrix Exact-Nonnegative-Integer (Immutable-Vectorof Float)))
(define (mat-row mat m)
  (vector-ref mat m))

(: mat-col (-> Matrix Exact-Nonnegative-Integer (Immutable-Vectorof Float)))
(define (mat-col mat n)
  (vector->immutable-vector
   (for/vector: : (Mutable-Vectorof Float)
                #:length (mat-m mat)
                ([row (in-vector mat)])
                (vector-ref row n))))

(: mat= (-> Matrix Matrix Boolean))
(define (mat= m1 m2)
  (for/and: : Boolean ([row1 (in-vector m1)] [row2 (in-vector m2)])
    (for/and: : Boolean ([col1 (in-vector row1)] [col2 (in-vector row2)])
      (f= col1 col2))))
#+END_SRC

A snippet to flatten a matrix into a 1D list if I ever need it.

#+BEGIN_SRC racket :noweb yes
(: flatten-mat (-> Matrix (Listof Float)))
(define (flatten-mat mat)
  (cast (flatten (vector->list (vector-map vector->list mat))) (Listof Float)))
#+END_SRC

** DONE Multiplying Matrices
#+NAME: build-matrix
#+BEGIN_SRC racket :noweb yes
(: build-matrix
   (-> Exact-Nonnegative-Integer
       Exact-Nonnegative-Integer
       (-> Exact-Nonnegative-Integer Exact-Nonnegative-Integer Float)
       Matrix))
(define (build-matrix m n f)
  (cast ((inst vector->immutable-vector (Immutable-Vectorof Float))
         (build-vector
          m
          (lambda ([row : Exact-Nonnegative-Integer])
            (vector->immutable-vector
             (build-vector n (lambda ([col : Exact-Nonnegative-Integer]) (f row col))))))) Matrix))
#+END_SRC

#+NAME: mat*
#+BEGIN_SRC racket :noweb yes
(: mat* (-> Matrix Matrix Matrix))
(define (mat* mat1 mat2)
  (: dot* (-> (Immutable-Vectorof Float) (Immutable-Vectorof Float) Float))
  (define (dot* v1 v2)
    (for/fold ([sum 0.]) ([x (in-vector v1)] [y (in-vector v2)])
      (+ sum (* x y))))
  (let ([m1 : Exact-Nonnegative-Integer (mat-m mat1)]
        [n1 : Exact-Nonnegative-Integer (mat-n mat1)]
        [m2 : Exact-Nonnegative-Integer (mat-m mat2)]
        [n2 : Exact-Nonnegative-Integer (mat-n mat2)])
    (if (= n1 m2)
        (build-matrix m1 n2
                      (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                        (dot* (mat-row mat1 row) (mat-col mat2 col))))
        (error "Illegal operation: multiply matrices with incompatible sizes" mat1 mat2))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
(: mat-t* (-> Matrix Tuple Tuple))
(define (mat-t* mat t)
  (: tuple->matrix (-> Tuple Matrix))
  (define (tuple->matrix t)
    (let ([rows : (Listof Float)
                (list (tuple-x t) (tuple-y t) (tuple-z t) (tuple-w t))])
      (build-matrix 4 1
                    (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                      ((inst list-ref Float) rows row)))))
  (: matrix->tuple (-> Matrix Tuple))
  (define (matrix->tuple m)
    (let ([x (mat-entry m 0 0)]
          [y (mat-entry m 1 0)]
          [z (mat-entry m 2 0)]
          [w (mat-entry m 3 0)])
      (cond
        [(= w 0) (vec x y z)]
        [(= w 1) (pt x y z)]
        [else (tuple x y z w)])))
  (matrix->tuple (mat* mat (tuple->matrix t))))
#+END_SRC

This code (matrix tuple multiplication) is on the hot path and is seems extremely inefficient. We will be multiplying 4x4 matrices with 4-tuples; let's just have a hard-coded version.

#+NAME: mat-t*
#+BEGIN_SRC racket :noweb yes
(: mat-t* (-> Matrix Tuple Tuple))
(define (mat-t* m t)
  (define-syntax-rule (dot* t1 t2)
    (+ (* (tuple-x t1) (tuple-x t2))
       (* (tuple-y t1) (tuple-y t2))
       (* (tuple-z t1) (tuple-z t2))
       (* (tuple-w t1) (tuple-w t2))))
  (: row->tuple (-> (Immutable-Vectorof Float) Tuple))
  (define (row->tuple row)
    (tuple (vector-ref row 0) (vector-ref row 1) (vector-ref row 2) (vector-ref row 3)))
  (let ([x (dot* (row->tuple (mat-row m 0)) t)]
        [y (dot* (row->tuple (mat-row m 1)) t)]
        [z (dot* (row->tuple (mat-row m 2)) t)]
        [w (dot* (row->tuple (mat-row m 3)) t)])
    (adaptive-tuple x y z w)))
#+END_SRC

** DONE The Identity Matrix
#+NAME: id-mat
#+BEGIN_SRC racket :noweb yes
(: id-mat (-> Exact-Nonnegative-Integer Matrix))
(define (id-mat n)
  (build-matrix n
                n
                (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                  (if (= row col) 1. 0.))))
#+END_SRC

The book says we pretty much only use the 4*4 identity matrix, so I'll just write it out.

#+NAME: id-mat-4
#+BEGIN_SRC racket :noweb yes
(: id-mat-4 Matrix)
(define id-mat-4
  (mat 4 4 #[#[1. 0. 0. 0.] #[0. 1. 0. 0.] #[0. 0. 1. 0.] #[0. 0. 0. 1.]]))
#+END_SRC

** DONE Transposing Matrices
#+NAME: transpose
#+BEGIN_SRC racket :noweb yes
(: transpose (-> Matrix Matrix))
(define (transpose mat)
  (cast ((inst vector->immutable-vector (Immutable-Vectorof Float))
   (build-vector (mat-n mat) (lambda ([y : Exact-Nonnegative-Integer]) (mat-col mat y)))) Matrix))
#+END_SRC

** DONE Inverting Matrices
*** Spotting Submatrices
#+NAME: submat
#+BEGIN_SRC racket :noweb yes
(: submat (-> Matrix Exact-Nonnegative-Integer Exact-Nonnegative-Integer Matrix))
(define (submat mat row col)
  (let ([rows (vector-append (vector-take mat row) (vector-drop mat (add1 row)))])
    (cast
     (vector->immutable-vector
      (for/vector ([y (in-vector rows)])
        (vector->immutable-vector (vector-append (vector-take y col) (vector-drop y (add1 col))))))
     Matrix)))
#+END_SRC
Had to cast in the end despite trying all kind of ways to convince the typechecker...

*** Calculating the Determinant
Cofactor expansion; refer to https://textbooks.math.gatech.edu/ila/determinants-cofactors.html; note that it refers to submatrices as minors instead of their determinant.
#+NAME: det
#+BEGIN_SRC racket :noweb yes
(: det-2 (-> Matrix Float))
(define (det-2 mat)
  (- (* (mat-entry mat 0 0) (mat-entry mat 1 1)) (* (mat-entry mat 0 1) (mat-entry mat 1 0))))

(: det (-> Matrix Float))
(define (det mat)
  (cond
    [(and (= (mat-m mat) 2) (= (mat-n mat) 2)) (det-2 mat)]
    [else
     (for/fold ([sum : Float 0.] [col : Exact-Nonnegative-Integer 0] #:result sum)
               ([elem (in-vector (mat-row mat 0))])
       (values
        (+ sum (* elem ((if (even? col) identity -) (det (submat mat 0 col)))))
        (add1 col)))]))
#+END_SRC

*** Implementing Inversion
We need a matrix of cofactors, so we'll implement ~cofactor~ even though we didn't do it for ~det~:
#+NAME: cofactor
#+BEGIN_SRC racket :noweb yes
(: cofactor (-> Matrix Exact-Nonnegative-Integer Exact-Nonnegative-Integer Float))
(define (cofactor mat row col)
  (if (or (>= row (mat-m mat)) (>= col (mat-n mat)))
      (error "Illegal operation: calculate cofactor out of bounds" mat row col)
      ((if (even? (+ row col)) identity -) (det (submat mat row col)))))
#+END_SRC

#+NAME: inverse
#+BEGIN_SRC racket :noweb yes
(: inverse (-> Matrix Matrix))
(define (inverse mat)
  (let ([m (mat-m mat)] [n (mat-n mat)] [determinant (det mat)])
    (if (or (not (= m n)) (= 0. determinant))
        (error "Illegal operation: matrix cannot be inverted" mat)
        (transpose (build-matrix
                    n
                    n
                    (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                      (/ (cofactor mat row col) determinant)))))))
#+END_SRC

** DONE Putting It Together
#+BEGIN_SRC racket :noweb yes
<<tuples>>
<<matrix-base>>
<<build-matrix>>
<<mat*>>
<<mat-t*>>
<<id-mat>>
<<id-mat-4>>
<<transpose>>
<<submat>>
<<det>>
<<cofactor>>
<<inverse>>

;; Q: What happens when you invert the identity matrix?
;; A: You get the identity matrix back
(inverse (id-mat 5))
;; Q: What do you get when you multiply a matrix by its inverse?
;; A: You get the identity matrix
(define a (mat 4 4 #[#[8. -5. 9. 2.] #[7. 5. 6. 1.] #[-6. 0. 9. 6.] #[-3. 0. -9. -4.]]))
(mat* a (inverse a))
;; Q: Is there any difference between the inverse of the transpose of a matrix, and the transpose of the inverse?
;; A: No
(inverse (transpose a))
(transpose (inverse a))

(define b (mat 4 4 #[#[-5. 2. 6. -8.] #[1. -5. 1. 8.] #[7. 7. -6. -7.] #[1. -3. 7. 4.]]))
(define c (mat 4 4 #[#[6. 4. 4. 4.] #[5. 5. 7. 6.] #[4. -9. 3. -7.] #[9. 1. 7. -6.]]))
;; associative
(mat* a (mat* b c))
(mat* (mat* a b) c)
;; non-commutative
(mat* a b)
(mat* b a)

(* (det b) (det c))
(det (mat* b c))
(det (mat* c b))
(* (det a) (det b) (det c))
(det (mat* a (mat* b c)))
(det (mat* b (mat* a c)))
(det (mat* c (mat* b a)))

(det id-mat-4)
#+END_SRC

#+RESULTS:
#+begin_example
'#(#(1.0 -0.0 0.0 -0.0 0.0) #(-0.0 1.0 -0.0 0.0 -0.0) #(0.0 -0.0 1.0 -0.0 0.0) #(-0.0 0.0 -0.0 1.0 -0.0) #(0.0 -0.0 0.0 -0.0 1.0))
'#(#(1.0 0.0 2.220446049250313e-16 4.440892098500626e-16) #(-2.220446049250313e-16 0.9999999999999998 -1.1102230246251565e-16 -2.220446049250313e-16) #(8.881784197001252e-16 8.881784197001252e-16 1.0 1.7763568394002505e-15) #(0.0 0.0 0.0 0.9999999999999991))
'#(#(-0.15384615384615385 -0.07692307692307693 0.358974358974359 -0.6923076923076923) #(-0.15384615384615385 0.12307692307692308 0.358974358974359 -0.6923076923076923) #(-0.28205128205128205 0.02564102564102564 0.4358974358974359 -0.7692307692307693) #(-0.5384615384615384 0.03076923076923077 0.9230769230769231 -1.9230769230769231))
'#(#(-0.15384615384615385 -0.07692307692307693 0.358974358974359 -0.6923076923076923) #(-0.15384615384615385 0.12307692307692308 0.358974358974359 -0.6923076923076923) #(-0.28205128205128205 0.02564102564102564 0.4358974358974359 -0.7692307692307693) #(-0.5384615384615384 0.03076923076923077 0.9230769230769231 -1.9230769230769231))
'#(#(-809.0 384.0 -338.0 1601.0) #(-196.0 -24.0 -76.0 418.0) #(648.0 1002.0 546.0 876.0) #(74.0 -494.0 -86.0 -1032.0))
'#(#(-809.0 384.0 -338.0 1601.0) #(-196.0 -24.0 -76.0 418.0) #(648.0 1002.0 546.0 876.0) #(74.0 -494.0 -86.0 -1032.0))
'#(#(20.0 98.0 3.0 -159.0) #(13.0 28.0 18.0 -54.0) #(99.0 33.0 -48.0 9.0) #(-52.0 -57.0 8.0 71.0))
'#(#(-38.0 35.0 93.0 60.0) #(-57.0 -30.0 -84.0 -29.0) #(162.0 0.0 114.0 13.0) #(-67.0 -20.0 18.0 25.0))
-1127840.0
-1127840.0
-1127840.0
659786400.0
659786400.0
659786400.0
659786400.0
1.0
#+end_example

#+NAME: matrix
#+BEGIN_SRC racket :noweb yes :tangle matrix.rkt
#lang typed/racket
(provide (except-out (all-defined-out) det-2))
(require "tuples.rkt")

<<matrix-base>>

<<build-matrix>>

<<mat*>>

<<mat-t*>>

<<id-mat>>

<<id-mat-4>>

<<transpose>>

<<submat>>

<<det>>

<<cofactor>>

<<inverse>>
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/matrix-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../matrix.rkt")

<<check-tuple=>>

(define matrix-test
  (test-suite
   "Matrices"
   (test-case
    "define matrix"
    (define m (mat 4 4 #[#[1. 2. 3. 4.] #[5.5 6.5 7.5 8.5] #[9. 10. 11. 12.] #[13.5 14.5 15.5 16.5]]))
    (check-equal? (mat-m m) 4)
    (check-equal? (mat-n m) 4)
    (check-equal? (mat-entry m 0 0) 1.)
    (check-equal? (mat-entry m 0 3) 4.)
    (check-equal? (mat-entry m 1 0) 5.5)
    (check-equal? (mat-entry m 1 2) 7.5)
    (check-equal? (mat-entry m 2 2) 11.)
    (check-equal? (mat-entry m 3 0) 13.5)
    (check-equal? (mat-entry m 3 2) 15.5)
    (define m2 (mat 2 2 #[#[-3. 5.] #[1. -2.]]))
    (check-equal? (mat-m m2) 2)
    (check-equal? (mat-n m2) 2)
    (check-equal? (mat-entry m2 0 0) -3.)
    (check-equal? (mat-entry m2 0 1) 5.)
    (check-equal? (mat-entry m2 1 0) 1.)
    (check-equal? (mat-entry m2 1 1) -2.)
    (define m3 (mat 3 3 #[#[-3. 5. 0.] #[1. -2. -7.] #[0. 1. 1.]]))
    (check-equal? (mat-m m3) 3)
    (check-equal? (mat-n m3) 3)
    (check-equal? (mat-entry m3 0 0) -3.)
    (check-equal? (mat-entry m3 1 1) -2.)
    (check-equal? (mat-entry m3 2 2) 1.))
   (test-case "compare matrix"
              (define a (mat 4 4 #[#[1. 2. 3. 4.] #[5. 6. 7. 8.] #[9. 8. 7. 6.] #[5. 4. 3. 2.]]))
              (define b (mat 4 4 #[#[1. 2. 3. 4.] #[5. 6. 7. 8.] #[9. 8. 7. 6.] #[5. 4. 3. 2.]]))
              (check-true (mat= a b))
              (define c (mat 4 4 #[#[2. 3. 4. 5.] #[6. 7. 8. 9.] #[8. 7. 6. 5.] #[4. 3. 2. 1.]]))
              (check-false (mat= a c)))
   (test-case "get matrix row and column"
              (define a (mat 4 4 #[#[1. 2. 3. 4.] #[5. 6. 7. 8.] #[9. 8. 7. 6.] #[5. 4. 3. 2.]]))
              (check-equal? (mat-row a 2) #[9. 8. 7. 6.])
              (check-equal? (mat-col a 1) #[2. 6. 8. 4.]))
   (test-case
    "multiply matrices"
    (define a (mat 4 4 #[#[1. 2. 3. 4.] #[5. 6. 7. 8.] #[9. 8. 7. 6.] #[5. 4. 3. 2.]]))
    (define b (mat 4 4 #[#[-2. 1. 2. 3.] #[3. 2. 1. -1.] #[4. 3. 6. 5.] #[1. 2. 7. 8.]]))
    (define c
      (mat 4 4 #[#[20. 22. 50. 48.] #[44. 54. 114. 108.] #[40. 58. 110. 102.] #[16. 26. 46. 42.]]))
    (check-true (mat= (mat* a b) c)))
   (test-case "multiply matrix by vector (tuple)"
              (define a (mat 4 4 #[#[1. 2. 3. 4.] #[2. 4. 4. 2.] #[8. 6. 4. 1.] #[0. 0. 0. 1.]]))
              (define b (tuple 1. 2. 3. 1.))
              (check-tuple= (mat-t* a b) (tuple 18. 24. 33. 1.)))
   (test-case "generate identity matrix" (check-true (mat= (id-mat 4) id-mat-4)))
   (test-case "multiply identity matrix"
              (define a (mat 4 4 #[#[0. 1. 2. 4.] #[1. 2. 4. 8.] #[2. 4. 8. 16.] #[4. 8. 16. 32.]]))
              (check-true (mat= (mat* a id-mat-4) a))
              (define b (tuple 1. 2. 3. 4.))
              (check-tuple= (mat-t* id-mat-4 b) b))
   (test-case "transpose matrices"
              (define a (mat 4 4 #[#[0. 9. 3. 0.] #[9. 8. 0. 8.] #[1. 8. 5. 3.] #[0. 0. 5. 8.]]))
              (define b (mat 4 4 #[#[0. 9. 1. 0.] #[9. 8. 8. 0.] #[3. 0. 5. 5.] #[0. 8. 3. 8.]]))
              (check-true (mat= (transpose a) b))
              (check-true (mat= (transpose b) a))
              (check-true (mat= (transpose id-mat-4) id-mat-4)))))

(define matrix-inversion-test
  (test-suite
   "Matrix Inversion"
   (test-case "find submatrices"
              (define a (mat 3 3 #[#[1. 5. 0.] #[-3. 2. 7.] #[0. 6. -3.]]))
              (define b (mat 2 2 #[#[-3. 2.] #[0. 6.]]))
              (check-true (mat= (submat a 0 2) b))
              (define c (mat 4 4 #[#[-6. 1. 1. 6.] #[-8. 5. 8. 6.] #[-1. 0. 8. 2.] #[-7. 1. -1. 1.]]))
              (define d (mat 3 3 #[#[-6. 1. 6.] #[-8. 8. 6.] #[-7. -1. 1.]]))
              (check-true (mat= (submat c 2 1) d)))
   (test-case "find cofactor"
              (define a (mat 3 3 #[#[3. 5. 0.] #[2. -1. -7.] #[6. -1. 5.]]))
              (check-equal? (cofactor a 0 0) -12.)
              (check-equal? (cofactor a 1 0) -25.))
   (test-case
    "find determinant of larger matrices"
    (define a (mat 3 3 #[#[1. 2. 6.] #[-5. 8. -4.] #[2. 6. 4.]]))
    (check-equal? (cofactor a 0 0) 56.)
    (check-equal? (cofactor a 0 1) 12.)
    (check-equal? (cofactor a 0 2) -46.)
    (check-equal? (det a) -196.)
    (define b (mat 4 4 #[#[-2. -8. 3. 5.] #[-3. 1. 7. 3.] #[1. 2. -9. 6.] #[-6. 7. 7. -9.]]))
    (check-equal? (cofactor b 0 0) 690.)
    (check-equal? (cofactor b 0 1) 447.)
    (check-equal? (cofactor b 0 2) 210.)
    (check-equal? (cofactor b 0 3) 51.)
    (check-equal? (det b) -4071.)
    (define c (mat 4 4 #[#[6. 4. 4. 4.] #[5. 5. 7. 6.] #[4. -9. 3. -7.] #[9. 1. 7. -6.]]))
    (check-equal? (det c) -2120.)
    (define d (mat 4 4 #[#[-4. 2. -2. -3.] #[9. 6. 2. 6.] #[0. -5. 1. -5.] #[0. 0. 0. 0.]]))
    (check-equal? (det d) 0.))
   (test-case
    "inverse matrix test 1"
    (define a (mat 4 4 #[#[-5. 2. 6. -8.] #[1. -5. 1. 8.] #[7. 7. -6. -7.] #[1. -3. 7. 4.]]))
    (define b (inverse a))
    (check-equal? (det a) 532.)
    (check-equal? (cofactor a 2 3) -160.)
    (check-= (mat-entry b 3 2) -160/532 0.00001)
    (check-equal? (cofactor a 3 2) 105.)
    (check-= (mat-entry b 2 3) 105/532 0.00001)
    (define c
      (mat 4
           4
           #[#[0.21805 0.45113 0.24060 -0.04511]
             #[-0.80827 -1.45677 -0.44361 0.52068]
             #[-0.07895 -0.22368 -0.05263 0.19737]
             #[-0.52256 -0.81391 -0.30075 0.30639]]))
    (check-true (mat= b c)))
   (test-case "inverse matrix test 2"
              (define a (mat 4 4 #[#[8. -5. 9. 2.] #[7. 5. 6. 1.] #[-6. 0. 9. 6.] #[-3. 0. -9. -4.]]))
              (define b
                (mat 4
                     4
                     #[#[-0.15385 -0.15385 -0.28205 -0.53846]
                       #[-0.07692 0.12308 0.02564 0.03077]
                       #[0.35897 0.35897 0.43590 0.92308]
                       #[-0.69231 -0.69231 -0.76923 -1.92308]]))
              (check-true (mat= (inverse a) b)))
   (test-case
    "inverse matrix test 3"
    (define a (mat 4 4 #[#[9. 3. 0. 9.] #[-5. -2. -6. -3.] #[-4. 9. 6. 4.] #[-7. 6. 6. 2.]]))
    (define b
      (mat 4
           4
           #[#[-0.04074 -0.07778 0.14444 -0.22222]
             #[-0.07778 0.03333 0.36667 -0.33333]
             #[-0.02901 -0.14630 -0.10926 0.12963]
             #[0.17778 0.06667 -0.26667 0.33333]]))
    (check-true (mat= (inverse a) b)))
   (test-case
    "multiply matrix product by inverse"
    (define a (mat 4 4 #[#[3. -9. 7. 3.] #[3. -8. 2. -9.] #[-4. 4. 4. 1.] #[-6. 5. -1. 1.]]))
    (define b (mat 4 4 #[#[8. 2. 2. 2.] #[3. -1. 7. 0.] #[7. 0. 5. 4.] #[6. -2. 0. 5.]]))
    (define c (mat* a b))
    (define d (mat* c (inverse b)))
    (check-true (mat= a d)))))

(run-tests matrix-test)
(run-tests matrix-inversion-test)
#+END_SRC

* DONE Matrix Transformations
:PROPERTIES:
:ACTIVATED: [2022-08-09]
:END:
** DONE Translation
#+NAME: translate
#+BEGIN_SRC racket :noweb yes
(: translate (-> Float Float Float Matrix))
(define (translate x y z)
  ;; 1 0 0 x
  ;; 0 1 0 y
  ;; 0 0 1 z
  ;; 0 0 0 1
  (build-matrix 4
                4
                (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                  (cond
                    [(= row col) 1.]
                    [(and (= row 0) (= col 3)) x]
                    [(and (= row 1) (= col 3)) y]
                    [(and (= row 2) (= col 3)) z]
                    [else 0.]))))
#+END_SRC

** DONE Scaling
#+NAME: scale
#+BEGIN_SRC racket :noweb yes
(: scale (-> Float Float Float Matrix))
(define (scale x y z)
  ;; x 0 0 0
  ;; 0 y 0 0
  ;; 0 0 z 0
  ;; 0 0 0 1
  (build-matrix 4
                4
                (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                  (cond
                    [(and (= row 0) (= col 0)) x]
                    [(and (= row 1) (= col 1)) y]
                    [(and (= row 2) (= col 2)) z]
                    [(and (= row 3) (= col 3)) 1.]
                    [else 0.]))))
#+END_SRC

** DONE Rotation
#+NAME: rotate
#+BEGIN_SRC racket :noweb yes
(: rotate (-> (U 'x 'y 'z) Float Matrix))
(define (rotate axis rad)
  (cond
    [(eq? axis 'x)
     ;; 1 0      0       0
     ;; 0 cos(r) −sin(r) 0
     ;; 0 sin(r) cos(r)  0
     ;; 0 0      0       1
     (build-matrix 4
                   4
                   (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                     (cond
                       [(and (= row 0) (= col 0)) 1.]
                       [(and (= row 1) (= col 1)) (cos rad)]
                       [(and (= row 1) (= col 2)) (- (sin rad))]
                       [(and (= row 2) (= col 1)) (sin rad)]
                       [(and (= row 2) (= col 2)) (cos rad)]
                       [(and (= row 3) (= col 3)) 1.]
                       [else 0.])))]
    [(eq? axis 'y)
     ;; cos(r)  0 sin(r) 0
     ;; 0       1 0      0
     ;; -sin(r) 0 cos(r) 0
     ;; 0       0 0      1
     (build-matrix 4
                   4
                   (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                     (cond
                       [(and (= row 0) (= col 0)) (cos rad)]
                       [(and (= row 0) (= col 2)) (sin rad)]
                       [(and (= row 1) (= col 1)) 1.]
                       [(and (= row 2) (= col 0)) (- (sin rad))]
                       [(and (= row 2) (= col 2)) (cos rad)]
                       [(and (= row 3) (= col 3)) 1.]
                       [else 0.])))]
    [(eq? axis 'z)
     ;; cos(r) −sin(r) 0 0
     ;; sin(r) cos(r)  0 0
     ;; 0      0       1 0
     ;; 0      0       0 1
     (build-matrix 4
                   4
                   (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                     (cond
                       [(and (= row 0) (= col 0)) (cos rad)]
                       [(and (= row 0) (= col 1)) (- (sin rad))]
                       [(and (= row 1) (= col 0)) (sin rad)]
                       [(and (= row 1) (= col 1)) (cos rad)]
                       [(and (= row 2) (= col 2)) 1.]
                       [(and (= row 3) (= col 3)) 1.]
                       [else 0.])))]))
#+END_SRC

** DONE Shearing
#+NAME: shear
#+BEGIN_SRC racket :noweb yes
(: shear (-> Float Float Float Float Float Float Matrix))
(define (shear dx/y dx/z dy/x dy/z dz/x dz/y)
  ;; 1    dx/y dx/z 0
  ;; dy/x 1    dy/z 0
  ;; dz/x dz/y 1    0
  ;; 0    0    0    1
  (build-matrix 4
                4
                (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                  (cond
                    [(and (= row 0) (= col 0)) 1.]
                    [(and (= row 0) (= col 1)) dx/y]
                    [(and (= row 0) (= col 2)) dx/z]
                    [(and (= row 1) (= col 0)) dy/x]
                    [(and (= row 1) (= col 1)) 1.]
                    [(and (= row 1) (= col 2)) dy/z]
                    [(and (= row 2) (= col 0)) dz/x]
                    [(and (= row 2) (= col 1)) dz/y]
                    [(and (= row 2) (= col 2)) 1.]
                    [(and (= row 3) (= col 3)) 1.]
                    [else 0.]))))
#+END_SRC

** DONE Chaining Transformations
#+NAME: transform
#+BEGIN_SRC racket :noweb yes
(: transformation (-> (Listof Matrix) Matrix))
(define (transformation transformations)
  (: iter (-> (Listof Matrix) Matrix Matrix))
  (define (iter remaining result)
    (if (null? remaining) result (iter (cdr remaining) (mat* (car remaining) result))))
  (iter transformations id-mat-4))

(: transform (-> Point Matrix * Point))
(define (transform pt . transformations)
  (assert (mat-t* (transformation transformations) pt) point?))
#+END_SRC

** DONE Putting It Together
#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require "tuples.rkt")
(require "canvas.rkt")
(require "matrix.rkt")

(define c (canvas 25 25))
(define origin (pt 0. 0. 0.))

(let ([center (transform origin (translate 12. 12. 0.))])
  (set-pixel! c
              (assert (exact-round (tuple-x center)) nonnegative-integer?)
              (assert (exact-round (tuple-y center)) nonnegative-integer?)
              (color 1. 1. 0.)))

(define twelve (pt 0. 1. 0.))

(for ([i (in-range 1 13)])
  (let ([hr (transform twelve (rotate 'z (cast (/ (* i pi) 6) Float)) (scale 10. 10. 10.) (translate 12. 12. 0.))])
  (set-pixel! c
              (assert (exact-round (tuple-x hr)) nonnegative-integer?)
              (assert (exact-round (tuple-y hr)) nonnegative-integer?)
              (color 1. 0. 0.))))

(save-canvas c "test.ppm")
#+END_SRC

#+NAME: transform
#+BEGIN_SRC racket :noweb yes :tangle transform.rkt
#lang typed/racket
(provide (all-defined-out))
(require "tuples.rkt")
(require "matrix.rkt")

<<translate>>

<<scale>>

<<rotate>>

<<shear>>

<<transform>>
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/transform-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../matrix.rkt"
         "../transform.rkt")

<<check-tuple=>>

(define transform-test
  (test-suite
   "Transformations"
   (test-suite "Translation"
               (test-case "Multiplying by a translation matrix"
                          (define t (translate 5. -3. 2.))
                          (define p (pt -3. 4. 5.))
                          (check-tuple= (mat-t* t p) (pt 2. 1. 7.)))
               (test-case "Multiplying by the inverse of a translate matrix"
                          (define t (translate 5. -3. 2.))
                          (define inv (inverse t))
                          (define p (pt -3. 4. 5.))
                          (check-tuple= (mat-t* inv p) (pt -8. 7. 3.)))
               (test-case "Translation does not affect vectors"
                          (define t (translate 5. -3. 2.))
                          (define v (vec -3. 4. 5.))
                          (check-tuple= (mat-t* t v) v)))
   (test-suite "scaling"
               (test-case "A scaling matrix applied to a point"
                          (define t (scale 2. 3. 4.))
                          (define p (pt -4. 6. 8.))
                          (check-tuple= (mat-t* t p) (pt -8. 18. 32.)))
               (test-case "A scaling matrix applied to a vector"
                          (define t (scale 2. 3. 4.))
                          (define v (vec -4. 6. 8.))
                          (check-tuple= (mat-t* t v) (vec -8. 18. 32.)))
               (test-case "Multiplying by the inverse of a scaling matrix"
                          (define t (scale 2. 3. 4.))
                          (define inv (inverse t))
                          (define v (vec -4. 6. 8.))
                          (check-tuple= (mat-t* inv v) (vec -2. 2. 2.)))
               (test-case "Reflection is scaling by a negative value"
                          (define t (scale -1. 1. 1.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt -2. 3. 4.))))
   (test-suite
    "rotation"
    (test-case "Rotating a point around the x axis"
               (define p (pt 0. 1. 0.))
               (define half-quarter (rotate 'x (/ pi 4)))
               (define full-quarter (rotate 'x (/ pi 2)))
               (check-tuple= (mat-t* half-quarter p)
                             (pt 0. (cast (/ (sqrt 2) 2) Float) (cast (/ (sqrt 2) 2) Float)))
               (check-tuple= (mat-t* full-quarter p) (pt 0. 0. 1.)))
    (test-case "The inverse of an x-rotation rotates in the opposite direction"
               (define p (pt 0. 1. 0.))
               (define half-quarter (rotate 'x (/ pi 4)))
               (define inv (inverse half-quarter))
               (check-tuple= (mat-t* inv p)
                             (pt 0. (cast (/ (sqrt 2) 2) Float) (cast (- (/ (sqrt 2) 2)) Float))))
    (test-case "Rotating a point around the y axis"
               (define p (pt 0. 0. 1.))
               (define half-quarter (rotate 'y (/ pi 4)))
               (define full-quarter (rotate 'y (/ pi 2)))
               (check-tuple= (mat-t* half-quarter p)
                             (pt (cast (/ (sqrt 2) 2) Float) 0. (cast (/ (sqrt 2) 2) Float)))
               (check-tuple= (mat-t* full-quarter p) (pt 1. 0. 0.)))
    (test-case "Rotating a point around the z axis"
               (define p (pt 0. 1. 0.))
               (define half-quarter (rotate 'z (/ pi 4)))
               (define full-quarter (rotate 'z (/ pi 2)))
               (check-tuple= (mat-t* half-quarter p)
                             (pt (cast (- (/ (sqrt 2) 2)) Float) (cast (/ (sqrt 2) 2) Float) 0.))
               (check-tuple= (mat-t* full-quarter p) (pt -1. 0. 0.))))
   (test-suite "shearing"
               (test-case "A shearing transformation moves x in proportion to y"
                          (define t (shear 1. 0. 0. 0. 0. 0.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt 5. 3. 4.)))
               (test-case "A shearing transformation moves x in proportion to z"
                          (define t (shear 0. 1. 0. 0. 0. 0.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt 6. 3. 4.)))
               (test-case "A shearing transformation moves y in proportion to x"
                          (define t (shear 0. 0. 1. 0. 0. 0.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt 2. 5. 4.)))
               (test-case "A shearing transformation moves y in proportion to z"
                          (define t (shear 0. 0. 0. 1. 0. 0.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt 2. 7. 4.)))
               (test-case "A shearing transformation moves z in proportion to x"
                          (define t (shear 0. 0. 0. 0. 1. 0.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt 2. 3. 6.)))
               (test-case "A shearing transformation moves z in proportion to y"
                          (define t (shear 0. 0. 0. 0. 0. 1.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt 2. 3. 7.))))
   (test-suite "chained transformations"
               (test-case "Chained transformations must be applied in reverse order"
                 (define p (pt 1. 0. 1.))
                 (define A (rotate 'x (/ pi 2)))
                 (define B (scale 5. 5. 5.))
                 (define C (translate 10. 5. 7.))
                 (check-tuple= (transform p A B C) (pt 15. 0. 7.))))))

(run-tests transform-test)
#+END_SRC

* Ray-Sphere Intersections
** Creating Rays
** Intersecting Rays with Spheres
** Tracking Intersections
** Identifying Hits
** Transforming Rays and Spheres
** Putting It Together
* Light and Shading
** Reflecting Vectors
** The Phong Reflection Model
** Putting It Together
* Making a Scene
** Building a World
** Defining a View Transformation
** Implementing a Camera
** Putting It Together
* Shadows
** Testing for Shadows
** Rendering Shadows
** Putting It Together
* Planes
** Refactoring Shapes
** Implementing a Plane
** Putting It Together
* Patterns
** Making a Striped Pattern
** Transforming Patterns
** Generalizing Patterns
** Making a Gradient Pattern
** Making a Ring Pattern
** Making a 3D Checker Pattern
** Putting It Together
* Reflection and Refraction
** Reflection
** Transparency and Refraction
** Fresnel Effect
** Putting It Together
* Cubes
** Intersecting a Ray with a Cube
** Finding the Normal on a Cube
** Putting It Together
* Cylinders
** Intersecting a Ray with a Cylinder
** Finding the Normal on a Cylinder
** Truncating Cylinders
** Capped Cylinders
** Cones
** Putting It Together
* Groups
** Implementing Groups
** Finding the Normal on a Child Object
** Using Bounding Boxes to Optimize Large Scenes
** Putting It Together
* Triangles
** Triangles
** Wavefront OBJ Files
** Smooth Triangles
** Smooth Triangles in OBJ Files
** Putting It Together
* Constructive Solid Geometry (CSG)
** Implementing CSG
** Coloring CSG Shapes
** Putting It Together
* Next Steps
** Area Lights and Soft Shadows
** Spotlights
** Focal Blur
** Motion Blur
** Anti-aliasing
** Texture Maps
** Normal Perturbation
** Torus Primitive
** Wrapping It Up
* Rendering the Cover Image
