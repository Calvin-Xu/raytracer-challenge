#+STARTUP: show2levels
#+TITLE:     The Ray Tracer Challenge Notes
#+AUTHOR:    Calvin Xu
#+EMAIL:     calvinxu806@gmail.com

* DONE Tuples, Points, and Vectors
:PROPERTIES:
:ACTIVATED: [2022-07-30]
:END:
** DONE Tuples
:PROPERTIES:
:ACTIVATED: [2022-07-30]
:END:
Left-handed coordinate system (+x right, +y up, +z away)

Note that Typed Racket currently does not support ~field-option~ in structs meaning we can't set ~w~ to ~#:auto~ to prepopulate values.

Since the book hints at some runtime checks/tricks in the way it defined points and vectors, ~pt?~ and ~vec?~ are currently implemented as this:

#+NAME: tuple-base
#+BEGIN_SRC racket :noweb yes
(struct tuple ([x : Real] [y : Real] [z : Real] [w : Real]) #:prefab #:type-name Tuple)
(struct point tuple () #:prefab #:type-name Point)
(struct vect tuple () #:prefab #:type-name Vector)

(: pt (-> Real Real Real Point))
(define (pt x y z)
  (point x y z 1))

(: pt? (-> Tuple Boolean))
(define (pt? t)
  (= (tuple-w t) 1))

(: vec (-> Real Real Real Vector))
(define (vec x y z)
  (vect x y z 0))

(: vec? (-> Tuple Boolean))
(define (vec? t)
  (= (tuple-w t) 0))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require typed/rackunit)
<<tuple-base>>
<<f=>>
<<check-tuple=>>

(define a (tuple 4.3 -4.2 3.1 1.0))

(check-equal? (tuple-x a) 4.3)
(check-equal? (tuple-y a) -4.2)
(check-equal? (tuple-z a) 3.1)
(check-equal? (tuple-w a) 1.0)
(check-true (pt? a))
(check-false (vec? a))

(define b (tuple 4.3 -4.2 3.1 0.0))

(check-equal? (tuple-x b) 4.3)
(check-equal? (tuple-y b) -4.2)
(check-equal? (tuple-z b) 3.1)
(check-equal? (tuple-w b) 0.0)
(check-false (pt? b))
(check-true (vec? b))

(define c (pt 4 -4 3))

(check-tuple= c (tuple 4 -4 3 1))

(define d (vec 4 -4 3))

(check-tuple= d (tuple 4 -4 3 0))
#+END_SRC

#+RESULTS:

We can compare floats in ~rackunit~ with [[https://docs.racket-lang.org/rackunit/api.html#(def._((lib._rackunit/main..rkt)._check-~3d))][(check-= v1 v2 epsilon [message])]]:

#+begin_example
(check-= 1.0 1.01 0.02 "I work")
(check-= 1.0 1.01 0.005 "I fail")
#+end_example

In case I need it outside of tests:

#+NAME: f=
#+BEGIN_SRC racket :noweb yes
(: f= (-> Real Real Boolean))
(define (f= a b)
  (: EPSILON Real)
  (define EPSILON 0.00001)
  (< (abs (- a b)) EPSILON))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
<<f=>>

(f= 1 1.000015)
(f= 1 1.000005)
#+END_SRC

#+RESULTS:
: #f
: #t

We should already be able to compare tuples for equality by making them ~#:prefab~. But then that isn't going to cut it. RackUnit's ~define-check~ seems broken in Typed Racket...I can't get a trivial example to work in the REPL and I can't find anyone's usage online. My own macro it is:

#+NAME: check-tuple=
#+BEGIN_SRC racket :noweb yes
(define-syntax-rule (check-tuple= t1 t2)
  (unless (and (f= (tuple-x t1) (tuple-x t2))
               (f= (tuple-y t1) (tuple-y t2))
               (f= (tuple-z t1) (tuple-z t2))
               (f= (tuple-w t1) (tuple-w t2)))
    (printf "Failure: tuples not equal ~v, ~v\n" t1 t2)))
#+END_SRC

** DONE Operations
:PROPERTIES:
:ACTIVATED: [2022-07-30]
:END:
*** Addition

- point + point -> ?
- point + vector -> point
- vector + point -> point
- vector + vector -> vector

#+NAME: tuple+
#+BEGIN_SRC racket :noweb yes
(: tuple+ (-> Tuple Tuple Tuple))
(define (tuple+ t1 t2)
  (let* ([xyzw : (List Real Real Real Real)
          (list (+ (tuple-x t1) (tuple-x t2))
                (+ (tuple-y t1) (tuple-y t2))
                (+ (tuple-z t1) (tuple-z t2))
                (+ (tuple-w t1) (tuple-w t2)))]
         [xyz : (List Real Real Real)
          (reverse (cdr (reverse xyzw)))])

    (cond
      [(and (pt? t1) (pt? t2) (error "Illegal operation: attempting point + point" t1 t2))]
      [(or (and (pt? t1) (vec? t2)) (and (pt? t2) (vec? t1))) (apply pt xyz)]
      [(and (vec? t1) (vec? t2)) (apply vec xyz)]
      [else (apply tuple xyzw)])))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require typed/rackunit)
<<tuple-base>>
<<tuple+>>
<<f=>>
<<check-tuple=>>

(check-tuple= (tuple+ (tuple 3 -2 5 1) (tuple -2 3 1 0)) (tuple 1 1 6 1))
#+END_SRC

#+RESULTS:

Let's make a variadic version:

#+BEGIN_SRC racket :noweb yes
(: tuples+ (-> Tuple * Tuple))
(define (tuples+ . tuples)
  (let loop ([sum (car tuples)] [args (cdr tuples)])
    (if (null? args) sum (loop (tuple+ sum (car args)) (cdr args)))))
#+END_SRC

...SICPish; or maybe try:

#+NAME: tuples+
#+BEGIN_SRC racket :noweb yes
(: tuples+ (-> Tuple * Tuple))
(define (tuples+ . tuples)
  (foldl tuple+ (tuple 0 0 0 0) tuples))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require typed/rackunit)
<<tuple-base>>
<<tuple+>>
<<tuples+>>
<<f=>>
<<check-tuple=>>

(check-tuple= (tuples+ (tuple 3 -2 5 1)) (tuple 3 -2 5 1))
(check-tuple= (tuples+ (tuple 3 -2 5 1) (tuple -2 3 1 0)) (tuple 1 1 6 1))
(check-tuple= (tuples+ (tuple 3 -2 5 1) (tuple -2 3 1 0) (tuple 1 1 1 0)) (tuple 2 2 7 1))
#+END_SRC

#+RESULTS:

*** Subtraction

- point - point -> vector
- point - vector -> point
- vector - point -> ?
- vector - vector -> vector

#+NAME: tuple-
#+BEGIN_SRC racket :noweb yes
(: tuple- (-> Tuple Tuple Tuple))
(define (tuple- t1 t2)
  (let* ([xyzw : (List Real Real Real Real)
          (list (- (tuple-x t1) (tuple-x t2))
                (- (tuple-y t1) (tuple-y t2))
                (- (tuple-z t1) (tuple-z t2))
                (- (tuple-w t1) (tuple-w t2)))]
         [xyz : (List Real Real Real)
          (reverse (cdr (reverse xyzw)))])

    (cond
      [(and (vec? t1) (pt? t2) (error "Illegal operation: attempting vector - point" t1 t2))]
      [(and (pt? t1) (pt? t2)) (apply vec xyz)]
      [(and (vec? t1) (vec? t2)) (apply vec xyz)]
      [(and (pt? t1) (vec? t2)) (apply pt xyz)]
      [else (apply tuple xyzw)])))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require typed/rackunit)
<<tuple-base>>
<<tuple->>
<<f=>>
<<check-tuple=>>

(check-tuple= (tuple- (pt 3 2 1) (pt 5 6 7)) (vec -2 -4 -6))
#+END_SRC

#+RESULTS:

#+NAME: tuples-
#+BEGIN_SRC racket :noweb yes
(: tuples- (-> Tuple * Tuple))
(define (tuples- . tuples)
  (foldl tuple+ (car tuples) (map -tuple (cdr tuples))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require typed/rackunit)
<<tuple-base>>
<<tuple+>>
<<-tuple>>
<<tuples->>
<<f=>>
<<check-tuple=>>

(check-tuple= (tuples- (tuple 3 -2 5 1)) (tuple 3 -2 5 1))
(check-tuple= (tuples- (tuple 3 -2 5 1) (tuple -2 3 1 0)) (tuple 5 -5 4 1))
(check-tuple= (tuples- (tuple 3 -2 5 1) (tuple -2 3 1 0) (tuple 1 1 1 1)) (tuple 4 -6 3 0))
#+END_SRC

#+RESULTS:

*** Negation
#+NAME: -tuple
#+BEGIN_SRC racket :noweb yes
(: -tuple (-> Tuple Tuple))
(define (-tuple t)
  (tuple (- (tuple-x t)) (- (tuple-y t)) (- (tuple-z t)) (- (tuple-w t))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require typed/rackunit)
<<tuple-base>>
<<tuple->>
<<-tuple>>
<<f=>>
<<check-tuple=>>

(check-tuple= (tuple- (vec 0 0 0) (vec 1 -2 3)) (vec -1 2 -3))
(check-tuple= (-tuple (tuple 1 -2 3 -4)) (tuple -1 2 -3 4))
#+END_SRC

#+RESULTS:

*** Scalar Multiplication and Division
#+NAME: tuple*
#+BEGIN_SRC racket :noweb yes
(: tuple* (-> Tuple Real Tuple))
(define (tuple* t s)
  (tuple (* (tuple-x t) s) (* (tuple-y t) s) (* (tuple-z t) s) (* (tuple-w t) s)))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require typed/rackunit)
<<tuple-base>>
<<tuple*>>
<<f=>>
<<check-tuple=>>

(define a (tuple 1 -2 3 -4))

(check-tuple= (tuple* a 3.5) (tuple 3.5 -7.0 10.5 -14.0))
(check-tuple= (tuple* a 0.5) (tuple 0.5 -1.0 1.5 -2.0))
#+END_SRC

#+RESULTS:

#+NAME: tuple/
#+BEGIN_SRC racket :noweb yes
(: tuple/ (-> Tuple Real Tuple))
(define (tuple/ t s)
  (tuple (/ (tuple-x t) s) (/ (tuple-y t) s) (/ (tuple-z t) s) (/ (tuple-w t) s)))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require typed/rackunit)
<<tuple-base>>
<<tuple/>>
<<f=>>
<<check-tuple=>>

(check-tuple= (tuple/ (tuple 1.0 -2 3.0 -4) 2) (tuple 0.5 -1 1.5 -2))
#+END_SRC

#+RESULTS:

*** Magnitude
#+NAME: mag
#+BEGIN_SRC racket :noweb yes
(: mag (-> Vector Real))
(define (mag v)
  (sqrt (+ (sqr (tuple-x v)) (sqr (tuple-y v)) (sqr (tuple-z v)))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require typed/rackunit)
<<tuple-base>>
<<mag>>

(check-= (mag (vec 1 0 0)) 1 0.00001)
(check-= (mag (vec 0 1 0)) 1 0.00001)
(check-= (mag (vec 0 0 1)) 1 0.00001)
(check-= (mag (vec 1 2 3)) (sqrt 14) 0.00001)
(check-= (mag (vec -1 -2 -3)) (sqrt 14) 0.00001)

;; (mag (pt 1 2 3))
#+END_SRC

#+RESULTS:

*** Normalization

#+NAME: norm
#+BEGIN_SRC racket :noweb yes
(: norm (-> Vector Vector))
(define (norm v)
  (let ([mag : Real (mag v)])
    (vec (/ (tuple-x v) mag) (/ (tuple-y v) mag) (/ (tuple-z v) mag))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require typed/rackunit)
<<tuple-base>>
<<mag>>
<<norm>>
<<f=>>
<<check-tuple=>>

(check-tuple= (norm (vec 4 0 0)) (vec 1 0 0))

(check-tuple= (norm (vec 1 2 3)) (vec 0.26726 0.53452 0.80178))

;; (norm (pt 1 2 3))
#+END_SRC

#+RESULTS:

*** Dot Product

#+NAME: dot*
#+BEGIN_SRC racket :noweb yes
(: dot* (-> Vector Vector Real))
(define (dot* v1 v2)
  (+ (* (tuple-x v1) (tuple-x v2))
     (* (tuple-y v1) (tuple-y v2))
     (* (tuple-z v1) (tuple-z v2))
     (* (tuple-w v1) (tuple-w v2))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require typed/rackunit)
<<tuple-base>>
<<dot*>>

(check-= (dot* (vec 1 2 3) (vec 2 3 4)) 20 0.00001)
#+END_SRC

#+RESULTS:

*** Cross Product

#+NAME: cross*
#+BEGIN_SRC racket :noweb yes
(: cross* (-> Vector Vector Vector))
(define (cross* v1 v2)
  (if (and (vec? v1) (vec? v2))
      (vec (- (* (tuple-y v1) (tuple-z v2)) (* (tuple-z v1) (tuple-y v2)))
              (- (* (tuple-z v1) (tuple-x v2)) (* (tuple-x v1) (tuple-z v2)))
              (- (* (tuple-x v1) (tuple-y v2)) (* (tuple-y v1) (tuple-x v2))))
      (error "Dot product on non-vector:" v1 v2)))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require typed/rackunit)
<<tuple-base>>
<<cross*>>
<<f=>>
<<check-tuple=>>

(check-tuple= (cross* (vec 1 2 3) (vec 2 3 4)) (vec -1 2 -1))
(check-tuple= (cross* (vec 2 3 4) (vec 1 2 3)) (vec 1 -2 1))
#+END_SRC

#+RESULTS:

** DONE Putting It Together
:PROPERTIES:
:ACTIVATED: [2022-07-31]
:END:
#+NAME: tuples
#+BEGIN_SRC racket :noweb yes :tangle tuples.rkt
#lang typed/racket

<<tuple-base>>

<<f=>>

<<tuple+>>

<<tuples+>>

<<tuple->>

<<tuples->>

<<-tuple>>

<<tuple*>>

<<tuple/>>

<<mag>>

<<norm>>

<<dot*>>

<<cross*>>

(provide (all-defined-out))
#+END_SRC

A fun playground:

#+BEGIN_SRC racket :noweb yes
<<tuples>>

(struct projectile ([position : Tuple] [velocity : Tuple]) #:prefab)
(struct environment ([gravity : Tuple] [wind : Tuple]) #:prefab)

(: tick (-> environment projectile projectile))
(define (tick env proj)
  (projectile (tuple+ (projectile-position proj) (projectile-velocity proj))
              (tuples+ (projectile-velocity proj) (environment-gravity env) (environment-wind env))))

(define p (projectile (pt 0 1 0) (norm (vec 1 1 0))))
(define e (environment (vec 0 -0.1 0) (vec -0.01 0 0)))

(: iter (-> environment projectile Integer Any))
(define (iter env proj n)
  (if (or (> n 100) (<= (tuple-y (projectile-position proj)) 0))
      (print "Hit ground")
      (begin
        (printf "Tick #~v\n" n)
        (printf "Position: ~v\n" (projectile-position proj))
        (iter e (tick e proj) (+ 1 n)))))

(iter e p 0)
#+END_SRC

#+RESULTS:
#+begin_example
Tick #0
Position: '#s(tuple 0 1 0 1)
Tick #1
Position: '#s(tuple 0.7071067811865475 1.7071067811865475 0 1)
Tick #2
Position: '#s(tuple 1.404213562373095 2.314213562373095 0 1)
Tick #3
Position: '#s(tuple 2.0913203435596426 2.821320343559642 0 1)
Tick #4
Position: '#s(tuple 2.7684271247461902 3.2284271247461898 0 1)
Tick #5
Position: '#s(tuple 3.4355339059327377 3.5355339059327373 0 1)
Tick #6
Position: '#s(tuple 4.092640687119285 3.7426406871192848 0 1)
Tick #7
Position: '#s(tuple 4.739747468305833 3.849747468305832 0 1)
Tick #8
Position: '#s(tuple 5.37685424949238 3.85685424949238 0 1)
Tick #9
Position: '#s(tuple 6.003961030678928 3.7639610306789275 0 1)
Tick #10
Position: '#s(tuple 6.621067811865475 3.571067811865475 0 1)
Tick #11
Position: '#s(tuple 7.228174593052023 3.2781745930520225 0 1)
Tick #12
Position: '#s(tuple 7.82528137423857 2.88528137423857 0 1)
Tick #13
Position: '#s(tuple 8.412388155425118 2.3923881554251176 0 1)
Tick #14
Position: '#s(tuple 8.989494936611665 1.7994949366116653 0 1)
Tick #15
Position: '#s(tuple 9.556601717798213 1.1066017177982128 0 1)
Tick #16
Position: '#s(tuple 10.11370849898476 0.3137084989847604 0 1)
"Hit ground"
#+end_example

In the future I'll have one big test suite instead of blocks after everything.

#+BEGIN_SRC racket :noweb yes :tangle tests/tuples-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt")

<<check-tuple=>>

(define tuples-test
  (test-suite "Tuples, Points, and Vectors"
              (test-case "tuple-base"
                         (define a (tuple 4.3 -4.2 3.1 1.0))
                         (check-equal? (tuple-x a) 4.3)
                         (check-equal? (tuple-y a) -4.2)
                         (check-equal? (tuple-z a) 3.1)
                         (check-equal? (tuple-w a) 1.0)
                         (check-true (pt? a))
                         (check-false (vec? a))
                         (define b (tuple 4.3 -4.2 3.1 0.0))
                         (check-equal? (tuple-x b) 4.3)
                         (check-equal? (tuple-y b) -4.2)
                         (check-equal? (tuple-z b) 3.1)
                         (check-equal? (tuple-w b) 0.0)
                         (check-false (pt? b))
                         (check-true (vec? b))
                         (define c (pt 4 -4 3))
                         (check-tuple= c (tuple 4 -4 3 1))
                         (define d (vec 4 -4 3))
                         (check-tuple= d (tuple 4 -4 3 0)))
              (test-case "addition"
                         (check-tuple= (tuple+ (tuple 3 -2 5 1) (tuple -2 3 1 0)) (tuple 1 1 6 1))
                         (check-tuple= (tuples+ (tuple 3 -2 5 1)) (tuple 3 -2 5 1))
                         (check-tuple= (tuples+ (tuple 3 -2 5 1) (tuple -2 3 1 0)) (tuple 1 1 6 1))
                         (check-tuple= (tuples+ (tuple 3 -2 5 1) (tuple -2 3 1 0) (tuple 1 1 1 0))
                                       (tuple 2 2 7 1)))
              (test-case "subtraction"
                         (check-tuple= (tuple- (pt 3 2 1) (pt 5 6 7)) (vec -2 -4 -6))
                         (check-tuple= (tuples- (tuple 3 -2 5 1)) (tuple 3 -2 5 1))
                         (check-tuple= (tuples- (tuple 3 -2 5 1) (tuple -2 3 1 0)) (tuple 5 -5 4 1))
                         (check-tuple= (tuples- (tuple 3 -2 5 1) (tuple -2 3 1 0) (tuple 1 1 1 1))
                                       (tuple 4 -6 3 0)))
              (test-case "negation"
                         (check-tuple= (tuple- (vec 0 0 0) (vec 1 -2 3)) (vec -1 2 -3))
                         (check-tuple= (-tuple (tuple 1 -2 3 -4)) (tuple -1 2 -3 4)))
              (test-case "multiplication and division"
                         (define a (tuple 1 -2 3 -4))
                         (check-tuple= (tuple* a 3.5) (tuple 3.5 -7.0 10.5 -14.0))
                         (check-tuple= (tuple* a 0.5) (tuple 0.5 -1.0 1.5 -2.0))
                         (check-tuple= (tuple/ (tuple 1.0 -2 3.0 -4) 2) (tuple 0.5 -1 1.5 -2)))
              (test-case "magnitude"
                         (check-= (mag (vec 1 0 0)) 1 0.00001)
                         (check-= (mag (vec 0 1 0)) 1 0.00001)
                         (check-= (mag (vec 0 0 1)) 1 0.00001)
                         (check-= (mag (vec 1 2 3)) (sqrt 14) 0.00001)
                         (check-= (mag (vec -1 -2 -3)) (sqrt 14) 0.00001))
              (test-case "normalization"
                         (check-tuple= (norm (vec 4 0 0)) (vec 1 0 0))
                         (check-tuple= (norm (vec 1 2 3)) (vec 0.26726 0.53452 0.80178)))
              (test-case "dot product" (check-= (dot* (vec 1 2 3) (vec 2 3 4)) 20 0.00001))
              (test-case "cross product"
                         (check-tuple= (cross* (vec 1 2 3) (vec 2 3 4)) (vec -1 2 -1))
                         (check-tuple= (cross* (vec 2 3 4) (vec 1 2 3)) (vec 1 -2 1)))))

(run-tests tuples-test)
#+END_SRC

* NEXT Drawing on a Canvas
:PROPERTIES:
:ACTIVATED: [2022-08-02]
:END:
** DONE Representing Colors
#+NAME: color-base
#+BEGIN_SRC racket :noweb yes
(struct _color tuple () #:prefab #:type-name Color)

(: color (-> Real Real Real Color))
(define (color red green blue)
  (_color red green blue 1))

(define color? _color?)

(: color-r (-> Color Real))
(define (color-r color)
  (tuple-x color))

(: color-g (-> Color Real))
(define (color-g color)
  (tuple-y color))

(: color-b (-> Color Real))
(define (color-b color)
  (tuple-z color))
#+END_SRC

** DONE Implementing Color Operations

I'd rather not reuse the tuple implementations...
#+NAME: color-ops
#+BEGIN_SRC racket :noweb yes
(: color-op (-> (-> Real Real * Real) Color Color Color))
(define (color-op op c1 c2)
  (color (op (color-r c1) (color-r c2))
         (op (color-g c1) (color-g c2))
         (op (color-b c1) (color-b c2))))

(: color+ (-> Color Color Color))
(define (color+ c1 c2)
  (color-op + c1 c2))

(: color- (-> Color Color Color))
(define (color- c1 c2)
  (color-op - c1 c2))

(: color* (-> Color (U Color Real) Color))
(define (color* c arg)
  (color-op * c (if (color? arg) arg (color arg arg arg))))
#+END_SRC

** TODO Creating a Canvas
** TODO Saving a Canvas
** TODO Putting It Together

#+NAME: canvas
#+BEGIN_SRC racket :noweb yes :tangle canvas.rkt
#lang typed/racket
(require "tuples.rkt")

<<color-base>>

<<color-ops>>

(provide (all-defined-out))
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/canvas-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../canvas.rkt")

<<check-tuple=>>

(define canvas-test
  (test-suite "Drawing on a Canvas"
              (test-case "define color"
                         (define c (color -0.5 0.4 1.7))
                         (check-equal? (color-r c) -0.5)
                         (check-equal? (color-g c) 0.4)
                         (check-equal? (color-b c) 1.7))
              (test-case "add color"
                         (define c1 (color 0.9 0.6 0.75))
                         (define c2 (color 0.7 0.1 0.25))
                         (check-tuple= (color+ c1 c2) (color 1.6 0.7 1.0)))
              (test-case "subtract color"
                         (define c1 (color 0.9 0.6 0.75))
                         (define c2 (color 0.7 0.1 0.25))
                         (check-tuple= (color- c1 c2) (color 0.2 0.5 0.5)))
              (test-case "multiply color"
                         (define c (color 0.2 0.3 0.4))
                         (check-tuple= (color* c 2) (color 0.4 0.6 0.8))
                         (define c1 (color 1 0.2 0.4))
                         (define c2 (color 0.9 1 0.1))
                         (check-tuple= (color* c1 c2) (color 0.9 0.2 0.04)))))

(run-tests canvas-test)
#+END_SRC

* Matrices
** Creating a Matrix
** Multiplying Matrices
** The Identity Matrix
** Transposing Matrices
** Inverting Matrices
** Putting It Together
* Matrix Transformations
** Translation
** Scaling
** Rotation
** Shearing
** Chaining Transformations
** Putting It Together
* Ray*Sphere Intersections
** Creating Rays
** Intersecting Rays with Spheres
** Tracking Intersections
** Identifying Hits
** Transforming Rays and Spheres
** Putting It Together
* Light and Shading
** Reflecting Vectors
** The Phong Reflection Model
** Putting It Together
* Making a Scene
** Building a World
** Defining a View Transformation
** Implementing a Camera
** Putting It Together
* Shadows
** Testing for Shadows
** Rendering Shadows
** Putting It Together
* Planes
** Refactoring Shapes
** Implementing a Plane
** Putting It Together
* Patterns
** Making a Striped Pattern
** Transforming Patterns
** Generalizing Patterns
** Making a Gradient Pattern
** Making a Ring Pattern
** Making a 3D Checker Pattern
** Putting It Together
* Reflection and Refraction
** Reflection
** Transparency and Refraction
** Fresnel Effect
** Putting It Together
* Cubes
** Intersecting a Ray with a Cube
** Finding the Normal on a Cube
** Putting It Together
* Cylinders
** Intersecting a Ray with a Cylinder
** Finding the Normal on a Cylinder
** Truncating Cylinders
** Capped Cylinders
** Cones
** Putting It Together
* Groups
** Implementing Groups
** Finding the Normal on a Child Object
** Using Bounding Boxes to Optimize Large Scenes
** Putting It Together
* Triangles
** Triangles
** Wavefront OBJ Files
** Smooth Triangles
** Smooth Triangles in OBJ Files
** Putting It Together
* Constructive Solid Geometry (CSG)
** Implementing CSG
** Coloring CSG Shapes
** Putting It Together
* Next Steps
** Area Lights and Soft Shadows
** Spotlights
** Focal Blur
** Motion Blur
** Anti*aliasing
** Texture Maps
** Normal Perturbation
** Torus Primitive
** Wrapping It Up
* Rendering the Cover Image
