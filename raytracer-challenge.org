#+STARTUP: show2levels
#+TITLE:     The Ray Tracer Challenge Notes
#+AUTHOR:    Calvin Xu
#+EMAIL:     calvinxu806@gmail.com

#+begin_quote
Admittedly, the explanations do tend toward imperative, procedural, and object-oriented languages, but the concepts and tests themselves are translatable to any environment you wish.
#+end_quote

My implementation will be in Typed Racket with unit tests in RackUnit. I will not be using "experimental" OOP features in ~typed/racket/class~ or other libraries in general. I also wanted to check out more (Typed) Racket features in this project, instead of sticking to probably more sensible options. Low-hanging optimization gains are done, but otherwise this is a learning project.

The codeblocks are mostly tangled such that there is one ~.rkt~ file corresponding to one chapter of the book. Perhaps I'll refactor them to be more reasonable in the end.

* TODO Future TODOs
** TODO Overload operators
** DONE Make rendering parallel
:PROPERTIES:
:ACTIVATED: [2022-08-31]
:COMPLETED: [2022-08-31]
:END:
#+NAME: render
#+BEGIN_SRC racket :noweb yes
(require racket/future)

(: render (->* (World Camera) (Exact-Positive-Integer Exact-Positive-Integer) Canvas))
(define (render w c [n-rays 1] [n-threads 1])
  (: render-pixel (-> Exact-Nonnegative-Integer Exact-Nonnegative-Integer Color))
  (define (render-pixel x y)
    (let* ([rays : (Listof Ray)
            (rays-to-pixel c x y n-rays)]
           [colors : (Listof Color)
            (map (lambda ([ray : Ray]) (shade-ray w ray)) rays)]
           [average : Color
            (if (= n-rays 1)
                (car colors)
                (color/ (apply colors+ colors) (exact->inexact (length rays))))])
      average))
  (let* ([width (camera-hsize c)]
         [height (camera-vsize c)]
         [n-total (* width height)]
         [n-each (quotient n-total n-threads)])
    (: render-slice (-> Exact-Nonnegative-Integer Exact-Nonnegative-Integer (Vectorof Color)))
    (define (render-slice n-todo n-before)
      (build-vector n-todo
                    (lambda ([n : Exact-Nonnegative-Integer])
                      (render-pixel (remainder (+ n n-before) width)
                                    (quotient (+ n n-before) width)))))
    (let ([slices : (Listof (Futureof (Vectorof Color)))
           (for/fold ([acc : (Listof (Futureof (Vectorof Color))) '()]
                      #:result (reverse acc))
                     ([i (in-range 0 n-threads)])
             (cons ((inst future (Vectorof Color))
                    (thunk (render-slice n-each (assert (* n-each i) nonnegative-integer?))))
                   acc))])
      (canvas width
              height
              (vector->immutable-vector
               (vector-append (apply vector-append (map (inst touch (Vectorof Color)) slices))
                              (render-slice (+ n-each (remainder n-total n-threads))
                                            (* (sub1 n-threads) n-each))))))))
#+END_SRC

* DONE Tuples, Points, and Vectors
:PROPERTIES:
:ACTIVATED: [2022-07-30]
:END:
** DONE Tuples
:PROPERTIES:
:ACTIVATED: [2022-07-30]
:END:
Left-handed coordinate system (+x right, +y up, +z away)

Note that Typed Racket currently does not support ~field-option~ in structs meaning we can't set ~w~ to ~#:auto~ to prepopulate values.

Since the book hints at some runtime checks/tricks in the way it defined points and vectors, ~pt?~ and ~vec?~ are currently implemented this way.

The constructors that accept ~Real~ are written so that Typed Racket accepts numbers without the decimal point in the source code for the tests...

#+NAME: tuple-base
#+BEGIN_SRC racket :noweb yes
(struct tuple ([x : Float] [y : Float] [z : Float] [w : Float]) #:prefab #:type-name Tuple)
(struct point tuple () #:prefab #:type-name Point)
(struct vect tuple () #:prefab #:type-name Vector)

(: pt (->* (Float Float Float) (Float) Point))
(define (pt x y z [w 1.])
  (point x y z w))

(: pt? (-> Tuple Boolean))
(define (pt? t)
  (= (tuple-w t) 1.))

(: vec (->* (Float Float Float) (Float) Vector))
(define (vec x y z [w 0.])
  (vect x y z w))

(: vec? (-> Tuple Boolean))
(define (vec? t)
  (= (tuple-w t) 0.))

(: adaptive-tuple (-> Float Float Float Float Tuple))
(define (adaptive-tuple x y z w)
  (cond
    [(= w 1.) (pt x y z)]
    [(= w 0.) (vec x y z)]
    [else (tuple x y z w)]))
#+END_SRC

Some failed attempt to generate propositions for the typechecker:

#+BEGIN_SRC racket :noweb yes
(: pt? (-> Any Boolean : Point))
(define (pt? t)
  (with-handlers ([exn:fail? (lambda (exn) #f)])
    (= (assert (tuple-w (assert t point?)) number?) 1.)))

(: vec? (-> Any Boolean : Vector))
(define (vec? t)
  (with-handlers ([exn:fail? (lambda (exn) #f)])
    (= (assert (tuple-w (assert t vect?)) number?) 0.)))
#+END_SRC

We can compare floats in ~rackunit~ with [[https://docs.racket-lang.org/rackunit/api.html#(def._((lib._rackunit/main..rkt)._check-~3d))][(check-= v1 v2 epsilon)]]:

#+begin_example
(check-= 1.0 1.01 0.02 "I work")
(check-= 1.0 1.01 0.005 "I fail")
#+end_example

In case I need it outside of tests:

#+NAME: f=
#+BEGIN_SRC racket :noweb yes
(: f= (-> Float Float Boolean))
(define (f= a b)
  (: EPSILON Float)
  (define EPSILON 0.00001)
  (< (abs (- a b)) EPSILON))
#+END_SRC

We should already be able to compare tuples for equality by making them ~#:prefab~. But then that isn't going to cut it. RackUnit's ~define-check~ seems broken in Typed Racket...I can't get a trivial example to work in the REPL and I can't find anyone's usage online. My own macro it is:

#+NAME: check-tuple=
#+BEGIN_SRC racket :noweb yes
(define-syntax-rule (check-tuple= t1 t2)
  (check-true (and (f= (tuple-x t1) (tuple-x t2))
                   (f= (tuple-y t1) (tuple-y t2))
                   (f= (tuple-z t1) (tuple-z t2))
                   (f= (tuple-w t1) (tuple-w t2)))
              (format "Failure: tuples not equal ~a ~a" t1 t2)))
#+END_SRC

** DONE Operations
:PROPERTIES:
:ACTIVATED: [2022-07-30]
:END:
*** Addition
- point + point -> ?
- point + vector -> point
- vector + point -> point
- vector + vector -> vector

#+NAME: tuple+
#+BEGIN_SRC racket :noweb yes
(: tuple+ (-> Tuple Tuple Tuple))
(define (tuple+ t1 t2)
  (let* ([xyzw : (List Float Float Float Float)
          (list (+ (tuple-x t1) (tuple-x t2))
                (+ (tuple-y t1) (tuple-y t2))
                (+ (tuple-z t1) (tuple-z t2))
                (+ (tuple-w t1) (tuple-w t2)))]
         [xyz : (List Float Float Float)
          (reverse (cdr (reverse xyzw)))])

    (cond
      [(and (pt? t1) (pt? t2) (error "Illegal operation: point + point" t1 t2))]
      [(or (and (pt? t1) (vec? t2)) (and (pt? t2) (vec? t1))) (apply pt xyz)]
      [(and (vec? t1) (vec? t2)) (apply vec xyz)]
      [else (apply tuple xyzw)])))
#+END_SRC

Let's make a variadic version:

#+BEGIN_SRC racket :noweb yes
(: tuples+ (-> Tuple * Tuple))
(define (tuples+ . tuples)
  (let loop ([sum (car tuples)] [args (cdr tuples)])
    (if (null? args) sum (loop (tuple+ sum (car args)) (cdr args)))))
#+END_SRC

...SICPish; or maybe try:

#+NAME: tuples+
#+BEGIN_SRC racket :noweb yes
(: tuples+ (-> Tuple * Tuple))
(define (tuples+ . tuples)
  (foldl tuple+ (tuple 0. 0. 0. 0.) tuples))
#+END_SRC

*** Subtraction
- point - point -> vector
- point - vector -> point
- vector - point -> ?
- vector - vector -> vector

#+NAME: tuple-
#+BEGIN_SRC racket :noweb yes
(: tuple- (-> Tuple Tuple Tuple))
(define (tuple- t1 t2)
  (let* ([x (- (tuple-x t1) (tuple-x t2))]
         [y (- (tuple-y t1) (tuple-y t2))]
         [z (- (tuple-z t1) (tuple-z t2))]
         [w (- (tuple-w t1) (tuple-w t2))])

    (cond
      [(and (vec? t1) (pt? t2) (error "Illegal operation: vector - point" t1 t2))]
      [(and (pt? t1) (pt? t2)) (vec x y z)]
      [(and (vec? t1) (vec? t2)) (vec x y z)]
      [(and (pt? t1) (vec? t2)) (pt x y z)]
      [else (tuple x y z w)])))
#+END_SRC

#+NAME: tuples-
#+BEGIN_SRC racket :noweb yes
(: tuples- (-> Tuple * Tuple))
(define (tuples- . tuples)
  ;; optimization when the list is known non-empty
  (if (null? tuples)
      (error "Illegal operation: no arguments provided")
      (foldl tuple+ (car tuples) (map -tuple (cdr tuples)))))
#+END_SRC

*** Negation
#+NAME: -tuple
#+BEGIN_SRC racket :noweb yes
(: -tuple (-> Tuple Tuple))
(define (-tuple t)
  (adaptive-tuple (- (tuple-x t)) (- (tuple-y t)) (- (tuple-z t)) (- (tuple-w t))))
#+END_SRC

*** Scalar Multiplication and Division
#+NAME: tuple*
#+BEGIN_SRC racket :noweb yes
(: tuple* (-> Tuple Float Tuple))
(define (tuple* t s)
  (adaptive-tuple (* (tuple-x t) s) (* (tuple-y t) s) (* (tuple-z t) s) (* (tuple-w t) s)))
#+END_SRC

#+NAME: tuple/
#+BEGIN_SRC racket :noweb yes
(: tuple/ (-> Tuple Float Tuple))
(define (tuple/ t s)
  (adaptive-tuple (/ (tuple-x t) s) (/ (tuple-y t) s) (/ (tuple-z t) s) (/ (tuple-w t) s)))
#+END_SRC

*** Magnitude
#+NAME: mag
#+BEGIN_SRC racket :noweb yes
(: mag (-> Vector Float))
(define (mag v)
  (sqrt (+ (sqr (tuple-x v)) (sqr (tuple-y v)) (sqr (tuple-z v)))))
#+END_SRC

*** Normalization
#+NAME: norm
#+BEGIN_SRC racket :noweb yes
(: norm (-> Vector Vector))
(define (norm v)
  (let ([mag : Float (mag v)])
    (vec (/ (tuple-x v) mag) (/ (tuple-y v) mag) (/ (tuple-z v) mag))))
#+END_SRC

*** Dot Product
#+NAME: dot*
#+BEGIN_SRC racket :noweb yes
(: dot* (-> Vector Vector Float))
(define (dot* v1 v2)
  (+ (* (tuple-x v1) (tuple-x v2))
     (* (tuple-y v1) (tuple-y v2))
     (* (tuple-z v1) (tuple-z v2))
     (* (tuple-w v1) (tuple-w v2))))
#+END_SRC

*** Cross Product
#+NAME: cross*
#+BEGIN_SRC racket :noweb yes
(: cross* (-> Vector Vector Vector))
(define (cross* v1 v2)
  (vec (- (* (tuple-y v1) (tuple-z v2)) (* (tuple-z v1) (tuple-y v2)))
       (- (* (tuple-z v1) (tuple-x v2)) (* (tuple-x v1) (tuple-z v2)))
       (- (* (tuple-x v1) (tuple-y v2)) (* (tuple-y v1) (tuple-x v2)))))
#+END_SRC

** DONE Putting It Together
:PROPERTIES:
:ACTIVATED: [2022-07-31]
:END:
A fun playground:

#+BEGIN_SRC racket :noweb yes
<<tuples>>

(struct projectile ([position : Tuple] [velocity : Tuple]) #:prefab)
(struct environment ([gravity : Tuple] [wind : Tuple]) #:prefab)

(: tick (-> environment projectile projectile))
(define (tick env proj)
  (projectile (tuple+ (projectile-position proj) (projectile-velocity proj))
              (tuples+ (projectile-velocity proj) (environment-gravity env) (environment-wind env))))

(define p (projectile (pt 0. 1. 0.) (norm (vec 1. 1. 0.))))
(define e (environment (vec 0. -0.1 0.) (vec -0.01 0. 0.)))

(: iter (-> environment projectile Integer Any))
(define (iter env proj n)
  (if (or (> n 100) (<= (tuple-y (projectile-position proj)) 0))
      (print "Hit ground")
      (begin
        (printf "Tick #~v\n" n)
        (printf "Position: ~v\n" (projectile-position proj))
        (iter e (tick e proj) (+ 1 n)))))

(iter e p 0)
#+END_SRC

#+RESULTS:
#+begin_example
Tick #0
Position: '#s((point tuple 4) 0.0 1.0 0.0 1.0)
Tick #1
Position: '#s((point tuple 4) 0.7071067811865475 1.7071067811865475 0.0 1.0)
Tick #2
Position: '#s((point tuple 4) 1.404213562373095 2.314213562373095 0.0 1.0)
Tick #3
Position: '#s((point tuple 4) 2.0913203435596426 2.821320343559642 0.0 1.0)
Tick #4
Position: '#s((point tuple 4) 2.7684271247461902 3.2284271247461898 0.0 1.0)
Tick #5
Position: '#s((point tuple 4) 3.4355339059327377 3.5355339059327373 0.0 1.0)
Tick #6
Position: '#s((point tuple 4) 4.092640687119285 3.7426406871192848 0.0 1.0)
Tick #7
Position: '#s((point tuple 4) 4.739747468305833 3.849747468305832 0.0 1.0)
Tick #8
Position: '#s((point tuple 4) 5.37685424949238 3.85685424949238 0.0 1.0)
Tick #9
Position: '#s((point tuple 4) 6.003961030678928 3.7639610306789275 0.0 1.0)
Tick #10
Position: '#s((point tuple 4) 6.621067811865475 3.571067811865475 0.0 1.0)
Tick #11
Position: '#s((point tuple 4) 7.228174593052023 3.2781745930520225 0.0 1.0)
Tick #12
Position: '#s((point tuple 4) 7.82528137423857 2.88528137423857 0.0 1.0)
Tick #13
Position: '#s((point tuple 4) 8.412388155425118 2.3923881554251176 0.0 1.0)
Tick #14
Position: '#s((point tuple 4) 8.989494936611665 1.7994949366116653 0.0 1.0)
Tick #15
Position: '#s((point tuple 4) 9.556601717798213 1.1066017177982128 0.0 1.0)
Tick #16
Position: '#s((point tuple 4) 10.11370849898476 0.3137084989847604 0.0 1.0)
"Hit ground"
#+end_example

#+BEGIN_SRC racket :noweb yes :tangle tests/tuples-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt")

<<check-tuple=>>

(define tuples-test
  (test-suite
   "Tuples, Points, and Vectors"
   (test-case "tuple-base"
              (define a (tuple 4.3 -4.2 3.1 1.0))
              (check-equal? (tuple-x a) 4.3)
              (check-equal? (tuple-y a) -4.2)
              (check-equal? (tuple-z a) 3.1)
              (check-equal? (tuple-w a) 1.0)
              (check-true (pt? a))
              (check-false (vec? a))
              (define b (tuple 4.3 -4.2 3.1 0.0))
              (check-equal? (tuple-x b) 4.3)
              (check-equal? (tuple-y b) -4.2)
              (check-equal? (tuple-z b) 3.1)
              (check-equal? (tuple-w b) 0.0)
              (check-false (pt? b))
              (check-true (vec? b))
              (define c (pt 4. -4. 3.))
              (check-tuple= c (tuple 4. -4. 3. 1.))
              (define d (vec 4. -4. 3.))
              (check-tuple= d (tuple 4. -4. 3. 0.)))
   (test-case "addition"
              (check-tuple= (tuple+ (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.)) (tuple 1. 1. 6. 1.))
              (check-tuple= (tuples+ (tuple 3. -2. 5. 1.)) (tuple 3. -2. 5. 1.))
              (check-tuple= (tuples+ (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.)) (tuple 1. 1. 6. 1.))
              (check-tuple= (tuples+ (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.) (tuple 1. 1. 1. 0.))
                            (tuple 2. 2. 7. 1.)))
   (test-case "subtraction"
              (check-tuple= (tuple- (pt 3. 2. 1.) (pt 5. 6. 7.)) (vec -2. -4. -6.))
              (check-tuple= (tuples- (tuple 3. -2. 5. 1.)) (tuple 3. -2. 5. 1.))
              (check-tuple= (tuples- (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.)) (tuple 5. -5. 4. 1.))
              (check-tuple= (tuples- (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.) (tuple 1. 1. 1. 1.))
                            (tuple 4. -6. 3. 0.)))
   (test-case "negation"
              (check-tuple= (tuple- (vec 0. 0. 0.) (vec 1. -2. 3.)) (vec -1. 2. -3.))
              (check-tuple= (-tuple (tuple 1. -2. 3. -4.)) (tuple -1. 2. -3. 4.)))
   (test-case "multiplication and division"
              (define a (tuple 1. -2. 3. -4.))
              (check-tuple= (tuple* a 3.5) (tuple 3.5 -7.0 10.5 -14.0))
              (check-tuple= (tuple* a 0.5) (tuple 0.5 -1.0 1.5 -2.0))
              (check-tuple= (tuple/ (tuple 1.0 -2. 3.0 -4.) 2.) (tuple 0.5 -1. 1.5 -2.)))
   (test-case "magnitude"
              (check-= (mag (vec 1. 0. 0.)) 1. 0.00001)
              (check-= (mag (vec 0. 1. 0.)) 1. 0.00001)
              (check-= (mag (vec 0. 0. 1.)) 1. 0.00001)
              (check-= (mag (vec 1. 2. 3.)) (sqrt 14.) 0.00001)
              (check-= (mag (vec -1. -2. -3.)) (sqrt 14.) 0.00001))
   (test-case "normalization"
              (check-tuple= (norm (vec 4. 0. 0.)) (vec 1. 0. 0.))
              (check-tuple= (norm (vec 1. 2. 3.)) (vec 0.26726 0.53452 0.80178)))
   (test-case "dot product" (check-= (dot* (vec 1. 2. 3.) (vec 2. 3. 4.)) 20. 0.00001))
   (test-case "cross product"
              (check-tuple= (cross* (vec 1. 2. 3.) (vec 2. 3. 4.)) (vec -1. 2. -1.))
              (check-tuple= (cross* (vec 2. 3. 4.) (vec 1. 2. 3.)) (vec 1. -2. 1.)))))

(run-tests tuples-test)
#+END_SRC

* DONE Drawing on a Canvas
:PROPERTIES:
:ACTIVATED: [2022-08-02]
:END:
** DONE Representing Colors
#+NAME: color-base
#+BEGIN_SRC racket :noweb yes
(struct color ([r : Float] [g : Float] [b : Float]) #:prefab #:type-name Color)

(: color->string (->* (Color) (Exact-Nonnegative-Integer) String))
(define (color->string color [max_color_val 255])
  (: scale (-> Float Integer))
  (define (scale frac)
    (exact-round (cast (* (max 0 (min 1.0 frac)) max_color_val) Float)))
  (string-append (number->string (scale (color-r color)))
                 " "
                 (number->string (scale (color-g color)))
                 " "
                 (number->string (scale (color-b color)))
                 " "))
#+END_SRC

#+NAME: check-color=
#+BEGIN_SRC racket :noweb yes
(define-syntax-rule (check-color= c1 c2)
  (check-true
   (and (f= (color-r c1) (color-r c2))
        (f= (color-g c1) (color-g c2))
        (f= (color-b c1) (color-b c2)))
   (format "Failure: colors not equal ~a ~a" c1 c2)))
#+END_SRC

** DONE Implementing Color Operations
I'd rather not reuse the tuple implementations...
#+NAME: color-ops
#+BEGIN_SRC racket :noweb yes
(: color-op (-> (-> Float Float * Float) Color Color Color))
(define (color-op op c1 c2)
  (color (op (color-r c1) (color-r c2))
         (op (color-g c1) (color-g c2))
         (op (color-b c1) (color-b c2))))

(: color+ (-> Color Color Color))
(define (color+ c1 c2)
  (color-op + c1 c2))

(: colors+ (-> Color * Color))
(define (colors+ . colors)
  (foldl color+ (color 0. 0. 0.) colors))

(: color- (-> Color Color Color))
(define (color- c1 c2)
  (color-op - c1 c2))

(: scalar-helper (-> (U Color Float) Color))
  (define (scalar-helper arg)
    (if (color? arg) arg (color arg arg arg)))

(: color* (-> (U Color Float) (U Color Float) Color))
(define (color* arg1 arg2)
  (color-op * (scalar-helper arg1) (scalar-helper arg2)))

(: color/ (-> Color (U Color Float) Color))
(define (color/ arg1 arg2)
  (color-op / (scalar-helper arg1) (scalar-helper arg2)))
#+END_SRC
#+NAME: colors
#+BEGIN_SRC racket :noweb yes
(define black (color 0. 0. 0.))

(define white (color 1. 1. 1.))
#+END_SRC

** DONE Creating a Canvas
I got very tempted by  ~math/array~, but it might be more educational to build my own:

#+NAME: canvas-mutable-base
#+BEGIN_SRC racket :noweb yes
(struct _canvas
  ([width : Exact-Positive-Integer]
   [height : Exact-Positive-Integer]
   [pixels : (Mutable-Vectorof Color)]) #:prefab #:type-name Canvas)

(: canvas-width (-> Canvas Exact-Positive-Integer))
(define (canvas-width canvas)
  (_canvas-width canvas))

(: canvas-height (-> Canvas Exact-Positive-Integer))
(define (canvas-height canvas)
  (_canvas-height canvas))

(: canvas-pixels (-> Canvas (Mutable-Vectorof Color)))
(define (canvas-pixels canvas)
  (_canvas-pixels canvas))

(: canvas (-> Exact-Positive-Integer Exact-Positive-Integer Canvas))
(define (canvas width height)
  (_canvas width height (make-vector (* width height) (color 0. 0. 0.))))

(: pixel-at (-> Canvas Exact-Nonnegative-Integer Exact-Nonnegative-Integer Color))
(define (pixel-at canvas x y)
  (if (or (>= x (canvas-width canvas)) (>= y (canvas-height canvas)))
      (error "Illegal operation: access pixel out of bounds" x y)
      (vector-ref (canvas-pixels canvas) (+ (* y (canvas-width canvas)) x))))

(: set-pixel! (-> Canvas Exact-Nonnegative-Integer Exact-Nonnegative-Integer Color Void))
(define (set-pixel! canvas x y color)
  (if (or (>= x (canvas-width canvas)) (>= y (canvas-height canvas)))
      (error "Illegal operation: set pixel out of bounds" x y)
      (vector-set! (canvas-pixels canvas) (+ (* y (canvas-width canvas)) x) color)))
#+END_SRC

** DONE Saving a Canvas
PPM format specs: http://netpbm.sourceforge.net/doc/ppm.html

The following is very bad because I couldn't figure out a functional way of doing this.

#+NAME: canvas-mutable-save
#+BEGIN_SRC racket :noweb yes
(: serialize-canvas (->* (Canvas) (Exact-Nonnegative-Integer) String))
(define (serialize-canvas canvas [max_color_val 255])
  (define header
    (string-append "P3\n"
                   (number->string (canvas-width canvas))
                   " "
                   (number->string (canvas-height canvas))
                   "\n"
                   (number->string max_color_val)
                   "\n"))
  (define bitmap (vector-map (lambda ([x : Color]) (color->string x max_color_val)) (canvas-pixels canvas)))
  ;; color->string always adds whitespace at end
  ;; replace appropriate whitespaces with newlines
  (begin
    (let ([PIXELS_PER_ROW 6] [n (* (canvas-width canvas) (canvas-height canvas))])
      (for ([i (in-range n)])
        (when (or (= (add1 i) n) (= 0 (remainder (add1 i) PIXELS_PER_ROW)))
          (let ([curr (vector-ref bitmap i)])
            (vector-set! bitmap
                         i
                         (string-append (substring curr 0 (sub1 (string-length curr))) "\n"))))))
    (string-append header (string-append* (vector->list bitmap)))))

(: save-canvas (-> Canvas String Void))
(define (save-canvas canvas filename)
  (let ([out (open-output-file filename #:mode 'text #:exists 'replace)])
    (display (serialize-canvas canvas) out)
    (close-output-port out)))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
<<tuple-base>>
<<color-base>>
<<color-ops>>
<<canvas-mutable-base>>
<<canvas-mutable-save>>

(define c (canvas 5 3))
(set-pixel! c 0 0 (color 1.5 0 0))
(set-pixel! c 2 1 (color 0 0.5 0))
(set-pixel! c 4 2 (color -0.5 0 1))

(serialize-canvas c)
(save-canvas c "test.ppm")
#+END_SRC

#+RESULTS:
: "P3\n5 3\n255\n255 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 255\n"

** DONE Refactor to use immutable datastructure & incremental export
:PROPERTIES:
:ACTIVATED: [2022-08-17]
:COMPLETED: [2022-08-17]
:END:
New canvas should be an immutable 2D vector that is created by the drawing code using a ~build-canvas~ procedure. Saving the Canvas should try to not hold the entire ppm string representation in memory, and write to file incrementally.

#+NAME: canvas-immutable
#+BEGIN_SRC racket :noweb yes
(struct canvas
        ([width : Exact-Positive-Integer]
         [height : Exact-Positive-Integer]
         [pixels : (Immutable-Vectorof Color)])
  #:prefab
  #:type-name Canvas)

(: build-canvas
   (-> Exact-Positive-Integer
       Exact-Positive-Integer
       (-> Exact-Nonnegative-Integer Exact-Nonnegative-Integer Color)
       Canvas))
(define (build-canvas width height f)
  (canvas width
          height
          (vector->immutable-vector
           (build-vector (ann (* width height) Integer)
                         (lambda ([n : Exact-Nonnegative-Integer])
                           (f (remainder n width) (quotient n width)))))))

(: pixel-at (-> Canvas Exact-Nonnegative-Integer Exact-Nonnegative-Integer Color))
(define (pixel-at canvas x y)
  (if (or (>= x (canvas-width canvas)) (>= y (canvas-height canvas)))
      (error "Illegal operation: access pixel out of bounds" x y)
      (vector-ref (canvas-pixels canvas) (+ (* y (canvas-width canvas)) x))))

(: save-canvas (->* (Canvas String) (Exact-Nonnegative-Integer) Void))
(define (save-canvas canvas filename [max_color_val 255])
  (define header
    (string-append "P3\n"
                   (number->string (canvas-width canvas))
                   " "
                   (number->string (canvas-height canvas))
                   "\n"
                   (number->string max_color_val)
                   "\n"))
  (define PIXELS_PER_ROW 6)
  (: add-newline (-> String String))
  (define (add-newline str)
    (string-append (substring str 0 (sub1 (string-length str))) "\n"))
  (let ([out (open-output-file filename #:mode 'text #:exists 'replace)])
    (display header out)
    (for/fold ([counter : Integer 1])
              ([pixel : Color (in-vector (canvas-pixels canvas))])
      (let ([serialized : String (color->string pixel max_color_val)])
        (display (if (= counter PIXELS_PER_ROW) (add-newline serialized) serialized) out))
      (if (= counter PIXELS_PER_ROW) 1 (add1 counter)))
    (close-output-port out)))
#+END_SRC

Example: ~(save-canvas (build-canvas 10 10 (lambda (x y) (if (= x y) black white))) "test.ppm")~

** DONE Putting It Together
#+BEGIN_SRC racket :noweb yes
<<tuples>>
<<color-base>>
<<color-ops>>
<<canvas-mutable-base>>
<<canvas-mutable-save>>

(struct projectile ([position : Tuple] [velocity : Tuple]) #:prefab)
(struct environment ([gravity : Tuple] [wind : Tuple]) #:prefab)

(: tick (-> environment projectile projectile))
(define (tick env proj)
  (projectile (tuple+ (projectile-position proj) (projectile-velocity proj))
              (tuples+ (projectile-velocity proj) (environment-gravity env) (environment-wind env))))

(define p (projectile (pt 0. 1. 0.) (tuple* (norm (vec 1. 1.8 0.)) 11.25)))
(define e (environment (vec 0. -0.1 0.) (vec -0.01 0. 0.)))
(define c (canvas 900 550))

(: iter (-> environment projectile Canvas Integer Any))
(define (iter env proj canvas n)
  (if (or (> n 200) (<= (tuple-y (projectile-position proj)) 0))
      (begin
        (print "Hit ground")
        (save-canvas canvas "test.ppm"))
      (begin
        (printf "Tick #~v\n" n)
        (let ([position (projectile-position proj)]
              [flip (lambda ([y : Integer]) (- (canvas-height canvas) y))])
          (printf "Position: ~v\n" position)
          (set-pixel! canvas
                      (assert (max 0 (exact-round (tuple-x position))) nonnegative-integer?)
                      (assert (max 0 (flip (exact-round (tuple-y position)))) nonnegative-integer?)
                      (color 1. 0. 0.)))
        (iter e (tick e proj) canvas (+ 1 n)))))

(iter e p c 0)
#+END_SRC

#+NAME: canvas-mutable
#+BEGIN_SRC racket :noweb yes :tangle "canvas-mutable.rkt"
#lang typed/racket
(display
 "Warning: the mutable implementation of canvas has been deprecated; using canvas.rkt is strongly recommended\n")
(provide (all-defined-out))
(require "color.rkt")

<<canvas-mutable-base>>

<<canvas-mutable-save>>
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/canvas-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../color.rkt"
         ;; "../canvas-mutable.rkt"
         "../canvas.rkt")

<<check-tuple=>>

<<check-color=>>

(define canvas-test
  (test-suite
   "Drawing on a Canvas"
   (test-case "define color"
              (define c (color -0.5 0.4 1.7))
              (check-equal? (color-r c) -0.5)
              (check-equal? (color-g c) 0.4)
              (check-equal? (color-b c) 1.7))
   (test-case "add color"
              (define c1 (color 0.9 0.6 0.75))
              (define c2 (color 0.7 0.1 0.25))
              (check-color= (color+ c1 c2) (color 1.6 0.7 1.0)))
   (test-case "subtract color"
              (define c1 (color 0.9 0.6 0.75))
              (define c2 (color 0.7 0.1 0.25))
              (check-color= (color- c1 c2) (color 0.2 0.5 0.5)))
   (test-case "multiply color"
              (define c (color 0.2 0.3 0.4))
              (check-color= (color* c 2.) (color 0.4 0.6 0.8))
              (define c1 (color 1. 0.2 0.4))
              (define c2 (color 0.9 1. 0.1))
              (check-color= (color* c1 c2) (color 0.9 0.2 0.04)))
   (test-case "color to string"
              (define c (color 0.2 0.3 0.4))
              (check-equal? (color->string c) "51 76 102 "))
   ;; (test-case "(deprecated) create and access mutable canvas"
   ;;            (define c (canvas 10 20))
   ;;            (check-equal? (canvas-width c) 10)
   ;;            (check-equal? (canvas-height c) 20)
   ;;            (define red (color 1. 0. 0.))
   ;;            (set-pixel! c 2 3 red)
   ;;            (check-equal? (pixel-at c 2 3) red))
   (test-case "create and access immutable canvas"
              (define c (build-canvas 10 20 (lambda (x y) (if (= x y) black white))))
              (check-equal? (canvas-width c) 10)
              (check-equal? (canvas-height c) 20)
              (check-equal? (pixel-at c 9 9) black)
              (check-equal? (pixel-at c 9 10) white))
   ;; (test-case
   ;;  "(deprecated) save canvas to ppm file"
   ;;  (define c (canvas 5 3))
   ;;  (set-pixel! c 0 0 (color 1.5 0. 0.))
   ;;  (set-pixel! c 2 1 (color 0. 0.5 0.))
   ;;  (set-pixel! c 4 2 (color -0.5 0. 1.))
   ;;  (check-equal?
   ;;   (serialize-canvas c)
   ;;   "P3\n5 3\n255\n255 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 255\n"))
   (test-case
    "save canvas to ppm file"
    (save-canvas (build-canvas 5 10 (lambda (x y) (if (= x y) black white))) "test.ppm")
    (check-equal?
     (file->string "test.ppm")
     "P3\n5 10\n255\n0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255\n0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255\n0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255\n0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255\n0 0 0 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255\n255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255\n255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255\n255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255\n255 255 255 255 255 255 "))))

(run-tests canvas-test)
#+END_SRC

* DONE Matrices
:PROPERTIES:
:ACTIVATED: [2022-08-05]
:END:
** DONE Creating a Matrix
It might be a good idea to use ~FlVector~, but I still want to try multidimensional vectors...

#+NAME: matrix-base
#+BEGIN_SRC racket :noweb yes
(define-type Matrix (Immutable-Vectorof (Immutable-Vectorof Float)))

(: mat
   (-> Exact-Nonnegative-Integer
       Exact-Nonnegative-Integer
       (Immutable-Vectorof (Immutable-Vectorof Float))
       Matrix))
(define (mat m n rows)
  (if (and (= m (vector-length rows))
           (andmap (lambda ([x : Integer]) (= x n)) (vector->list (vector-map vector-length rows))))
      rows
      (error "Illegal operation: input not m by n 2D immutable vector" rows)))

(: mat-m (-> Matrix Exact-Nonnegative-Integer))
(define (mat-m mat)
  (vector-length mat))

(: mat-n (-> Matrix Exact-Nonnegative-Integer))
(define (mat-n mat)
  (vector-length (vector-ref mat 0)))

(: mat-entry (-> Matrix Exact-Nonnegative-Integer Exact-Nonnegative-Integer Float))
(define (mat-entry mat m n)
  (if (or (>= m (mat-m mat)) (>= n (mat-n mat)))
      (error "Illegal operation: access matrix element out of bounds")
      (vector-ref (vector-ref mat m) n)))

(: mat-row (-> Matrix Exact-Nonnegative-Integer (Immutable-Vectorof Float)))
(define (mat-row mat m)
  (vector-ref mat m))

(: mat-col (-> Matrix Exact-Nonnegative-Integer (Immutable-Vectorof Float)))
(define (mat-col mat n)
  (vector->immutable-vector
   (for/vector: : (Mutable-Vectorof Float)
                #:length (mat-m mat)
                ([row (in-vector mat)])
                (vector-ref row n))))

(: mat= (-> Matrix Matrix Boolean))
(define (mat= m1 m2)
  (for/and: : Boolean ([row1 (in-vector m1)] [row2 (in-vector m2)])
    (for/and: : Boolean ([col1 (in-vector row1)] [col2 (in-vector row2)])
      (f= col1 col2))))
#+END_SRC

A snippet to flatten a matrix into a 1D list if I ever need it.

#+BEGIN_SRC racket :noweb yes
(: flatten-mat (-> Matrix (Listof Float)))
(define (flatten-mat mat)
  (cast (flatten (vector->list (vector-map vector->list mat))) (Listof Float)))
#+END_SRC

** DONE Multiplying Matrices
#+NAME: build-matrix
#+BEGIN_SRC racket :noweb yes
(: build-matrix
   (-> Exact-Nonnegative-Integer
       Exact-Nonnegative-Integer
       (-> Exact-Nonnegative-Integer Exact-Nonnegative-Integer Float)
       Matrix))
(define (build-matrix m n f)
  (cast ((inst vector->immutable-vector (Immutable-Vectorof Float))
         (build-vector
          m
          (lambda ([row : Exact-Nonnegative-Integer])
            (vector->immutable-vector
             (build-vector n (lambda ([col : Exact-Nonnegative-Integer]) (f row col))))))) Matrix))
#+END_SRC

#+NAME: mat*
#+BEGIN_SRC racket :noweb yes
(: mat* (-> Matrix Matrix Matrix))
(define (mat* mat1 mat2)
  (: dot* (-> (Immutable-Vectorof Float) (Immutable-Vectorof Float) Float))
  (define (dot* v1 v2)
    (for/fold ([sum 0.]) ([x (in-vector v1)] [y (in-vector v2)])
      (+ sum (* x y))))
  (let ([m1 : Exact-Nonnegative-Integer (mat-m mat1)]
        [n1 : Exact-Nonnegative-Integer (mat-n mat1)]
        [m2 : Exact-Nonnegative-Integer (mat-m mat2)]
        [n2 : Exact-Nonnegative-Integer (mat-n mat2)])
    (if (= n1 m2)
        (build-matrix m1 n2
                      (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                        (dot* (mat-row mat1 row) (mat-col mat2 col))))
        (error "Illegal operation: multiply matrices with incompatible sizes" mat1 mat2))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
(: mat-t* (-> Matrix Tuple Tuple))
(define (mat-t* mat t)
  (: tuple->matrix (-> Tuple Matrix))
  (define (tuple->matrix t)
    (let ([rows : (Listof Float)
                (list (tuple-x t) (tuple-y t) (tuple-z t) (tuple-w t))])
      (build-matrix 4 1
                    (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                      ((inst list-ref Float) rows row)))))
  (: matrix->tuple (-> Matrix Tuple))
  (define (matrix->tuple m)
    (let ([x (mat-entry m 0 0)]
          [y (mat-entry m 1 0)]
          [z (mat-entry m 2 0)]
          [w (mat-entry m 3 0)])
      (cond
        [(= w 0) (vec x y z)]
        [(= w 1) (pt x y z)]
        [else (tuple x y z w)])))
  (matrix->tuple (mat* mat (tuple->matrix t))))
#+END_SRC

This code (matrix tuple multiplication) is on the hot path and is seems extremely inefficient. We will be multiplying 4x4 matrices with 4-tuples; let's just have a hard-coded version.

#+NAME: mat-t*
#+BEGIN_SRC racket :noweb yes
(: mat-t* (-> Matrix Tuple Tuple))
(define (mat-t* m t)
  (define-syntax-rule (dot* t1 t2)
    (+ (* (tuple-x t1) (tuple-x t2))
       (* (tuple-y t1) (tuple-y t2))
       (* (tuple-z t1) (tuple-z t2))
       (* (tuple-w t1) (tuple-w t2))))
  (: row->tuple (-> (Immutable-Vectorof Float) Tuple))
  (define (row->tuple row)
    (tuple (vector-ref row 0) (vector-ref row 1) (vector-ref row 2) (vector-ref row 3)))
  (let ([x (dot* (row->tuple (mat-row m 0)) t)]
        [y (dot* (row->tuple (mat-row m 1)) t)]
        [z (dot* (row->tuple (mat-row m 2)) t)]
        [w (dot* (row->tuple (mat-row m 3)) t)])
    (adaptive-tuple x y z w)))
#+END_SRC

** DONE The Identity Matrix
#+NAME: id-mat
#+BEGIN_SRC racket :noweb yes
(: id-mat (-> Exact-Nonnegative-Integer Matrix))
(define (id-mat n)
  (build-matrix n
                n
                (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                  (if (= row col) 1. 0.))))
#+END_SRC

The book says we pretty much only use the 4*4 identity matrix, so I'll just write it out.

#+NAME: id-mat-4
#+BEGIN_SRC racket :noweb yes
(: id-mat-4 Matrix)
(define id-mat-4
  (mat 4 4 #[#[1. 0. 0. 0.] #[0. 1. 0. 0.] #[0. 0. 1. 0.] #[0. 0. 0. 1.]]))
#+END_SRC

** DONE Transposing Matrices
#+NAME: transpose
#+BEGIN_SRC racket :noweb yes
(: transpose (-> Matrix Matrix))
(define (transpose mat)
  (cast ((inst vector->immutable-vector (Immutable-Vectorof Float))
   (build-vector (mat-n mat) (lambda ([y : Exact-Nonnegative-Integer]) (mat-col mat y)))) Matrix))
#+END_SRC

** DONE Inverting Matrices
*** Spotting Submatrices
#+NAME: submat
#+BEGIN_SRC racket :noweb yes
(: submat (-> Matrix Exact-Nonnegative-Integer Exact-Nonnegative-Integer Matrix))
(define (submat mat row col)
  (let ([rows (vector-append (vector-take mat row) (vector-drop mat (add1 row)))])
    (cast
     (vector->immutable-vector
      (for/vector ([y (in-vector rows)])
        (vector->immutable-vector (vector-append (vector-take y col) (vector-drop y (add1 col))))))
     Matrix)))
#+END_SRC
Had to cast in the end despite trying all kind of ways to convince the typechecker...

*** Calculating the Determinant
Cofactor expansion; refer to https://textbooks.math.gatech.edu/ila/determinants-cofactors.html; note that it refers to submatrices as minors instead of their determinant.
#+NAME: det
#+BEGIN_SRC racket :noweb yes
(: det-2 (-> Matrix Float))
(define (det-2 mat)
  (- (* (mat-entry mat 0 0) (mat-entry mat 1 1)) (* (mat-entry mat 0 1) (mat-entry mat 1 0))))

(: det (-> Matrix Float))
(define (det mat)
  (cond
    [(and (= (mat-m mat) 2) (= (mat-n mat) 2)) (det-2 mat)]
    [else
     (for/fold ([sum : Float 0.] [col : Exact-Nonnegative-Integer 0] #:result sum)
               ([elem (in-vector (mat-row mat 0))])
       (values
        (+ sum (* elem ((if (even? col) identity -) (det (submat mat 0 col)))))
        (add1 col)))]))
#+END_SRC

*** Implementing Inversion
We need a matrix of cofactors, so we'll implement ~cofactor~ even though we didn't do it for ~det~:
#+NAME: cofactor
#+BEGIN_SRC racket :noweb yes
(: cofactor (-> Matrix Exact-Nonnegative-Integer Exact-Nonnegative-Integer Float))
(define (cofactor mat row col)
  (if (or (>= row (mat-m mat)) (>= col (mat-n mat)))
      (error "Illegal operation: calculate cofactor out of bounds" mat row col)
      ((if (even? (+ row col)) identity -) (det (submat mat row col)))))
#+END_SRC

#+NAME: inverse
#+BEGIN_SRC racket :noweb yes
(: inverse (-> Matrix Matrix))
(define (inverse mat)
  (let ([m (mat-m mat)] [n (mat-n mat)] [determinant (det mat)])
    (if (or (not (= m n)) (= 0. determinant))
        (error "Illegal operation: matrix cannot be inverted" mat)
        (transpose (build-matrix
                    n
                    n
                    (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                      (/ (cofactor mat row col) determinant)))))))
#+END_SRC

** DONE Putting It Together
#+BEGIN_SRC racket :noweb yes
<<tuples>>
<<matrix-base>>
<<build-matrix>>
<<mat*>>
<<mat-t*>>
<<id-mat>>
<<id-mat-4>>
<<transpose>>
<<submat>>
<<det>>
<<cofactor>>
<<inverse>>

;; Q: What happens when you invert the identity matrix?
;; A: You get the identity matrix back
(inverse (id-mat 5))
;; Q: What do you get when you multiply a matrix by its inverse?
;; A: You get the identity matrix
(define a (mat 4 4 #[#[8. -5. 9. 2.] #[7. 5. 6. 1.] #[-6. 0. 9. 6.] #[-3. 0. -9. -4.]]))
(mat* a (inverse a))
;; Q: Is there any difference between the inverse of the transpose of a matrix, and the transpose of the inverse?
;; A: No
(inverse (transpose a))
(transpose (inverse a))

(define b (mat 4 4 #[#[-5. 2. 6. -8.] #[1. -5. 1. 8.] #[7. 7. -6. -7.] #[1. -3. 7. 4.]]))
(define c (mat 4 4 #[#[6. 4. 4. 4.] #[5. 5. 7. 6.] #[4. -9. 3. -7.] #[9. 1. 7. -6.]]))
;; associative
(mat* a (mat* b c))
(mat* (mat* a b) c)
;; non-commutative
(mat* a b)
(mat* b a)

(* (det b) (det c))
(det (mat* b c))
(det (mat* c b))
(* (det a) (det b) (det c))
(det (mat* a (mat* b c)))
(det (mat* b (mat* a c)))
(det (mat* c (mat* b a)))

(det id-mat-4)
#+END_SRC

#+RESULTS:
#+begin_example
'#(#(1.0 -0.0 0.0 -0.0 0.0) #(-0.0 1.0 -0.0 0.0 -0.0) #(0.0 -0.0 1.0 -0.0 0.0) #(-0.0 0.0 -0.0 1.0 -0.0) #(0.0 -0.0 0.0 -0.0 1.0))
'#(#(1.0 0.0 2.220446049250313e-16 4.440892098500626e-16) #(-2.220446049250313e-16 0.9999999999999998 -1.1102230246251565e-16 -2.220446049250313e-16) #(8.881784197001252e-16 8.881784197001252e-16 1.0 1.7763568394002505e-15) #(0.0 0.0 0.0 0.9999999999999991))
'#(#(-0.15384615384615385 -0.07692307692307693 0.358974358974359 -0.6923076923076923) #(-0.15384615384615385 0.12307692307692308 0.358974358974359 -0.6923076923076923) #(-0.28205128205128205 0.02564102564102564 0.4358974358974359 -0.7692307692307693) #(-0.5384615384615384 0.03076923076923077 0.9230769230769231 -1.9230769230769231))
'#(#(-0.15384615384615385 -0.07692307692307693 0.358974358974359 -0.6923076923076923) #(-0.15384615384615385 0.12307692307692308 0.358974358974359 -0.6923076923076923) #(-0.28205128205128205 0.02564102564102564 0.4358974358974359 -0.7692307692307693) #(-0.5384615384615384 0.03076923076923077 0.9230769230769231 -1.9230769230769231))
'#(#(-809.0 384.0 -338.0 1601.0) #(-196.0 -24.0 -76.0 418.0) #(648.0 1002.0 546.0 876.0) #(74.0 -494.0 -86.0 -1032.0))
'#(#(-809.0 384.0 -338.0 1601.0) #(-196.0 -24.0 -76.0 418.0) #(648.0 1002.0 546.0 876.0) #(74.0 -494.0 -86.0 -1032.0))
'#(#(20.0 98.0 3.0 -159.0) #(13.0 28.0 18.0 -54.0) #(99.0 33.0 -48.0 9.0) #(-52.0 -57.0 8.0 71.0))
'#(#(-38.0 35.0 93.0 60.0) #(-57.0 -30.0 -84.0 -29.0) #(162.0 0.0 114.0 13.0) #(-67.0 -20.0 18.0 25.0))
-1127840.0
-1127840.0
-1127840.0
659786400.0
659786400.0
659786400.0
659786400.0
1.0
#+end_example

#+BEGIN_SRC racket :noweb yes :tangle tests/matrix-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../matrix.rkt")

<<check-tuple=>>

(define matrix-test
  (test-suite
   "Matrices"
   (test-case
    "define matrix"
    (define m (mat 4 4 #[#[1. 2. 3. 4.] #[5.5 6.5 7.5 8.5] #[9. 10. 11. 12.] #[13.5 14.5 15.5 16.5]]))
    (check-equal? (mat-m m) 4)
    (check-equal? (mat-n m) 4)
    (check-equal? (mat-entry m 0 0) 1.)
    (check-equal? (mat-entry m 0 3) 4.)
    (check-equal? (mat-entry m 1 0) 5.5)
    (check-equal? (mat-entry m 1 2) 7.5)
    (check-equal? (mat-entry m 2 2) 11.)
    (check-equal? (mat-entry m 3 0) 13.5)
    (check-equal? (mat-entry m 3 2) 15.5)
    (define m2 (mat 2 2 #[#[-3. 5.] #[1. -2.]]))
    (check-equal? (mat-m m2) 2)
    (check-equal? (mat-n m2) 2)
    (check-equal? (mat-entry m2 0 0) -3.)
    (check-equal? (mat-entry m2 0 1) 5.)
    (check-equal? (mat-entry m2 1 0) 1.)
    (check-equal? (mat-entry m2 1 1) -2.)
    (define m3 (mat 3 3 #[#[-3. 5. 0.] #[1. -2. -7.] #[0. 1. 1.]]))
    (check-equal? (mat-m m3) 3)
    (check-equal? (mat-n m3) 3)
    (check-equal? (mat-entry m3 0 0) -3.)
    (check-equal? (mat-entry m3 1 1) -2.)
    (check-equal? (mat-entry m3 2 2) 1.))
   (test-case "compare matrix"
              (define a (mat 4 4 #[#[1. 2. 3. 4.] #[5. 6. 7. 8.] #[9. 8. 7. 6.] #[5. 4. 3. 2.]]))
              (define b (mat 4 4 #[#[1. 2. 3. 4.] #[5. 6. 7. 8.] #[9. 8. 7. 6.] #[5. 4. 3. 2.]]))
              (check-true (mat= a b))
              (define c (mat 4 4 #[#[2. 3. 4. 5.] #[6. 7. 8. 9.] #[8. 7. 6. 5.] #[4. 3. 2. 1.]]))
              (check-false (mat= a c)))
   (test-case "get matrix row and column"
              (define a (mat 4 4 #[#[1. 2. 3. 4.] #[5. 6. 7. 8.] #[9. 8. 7. 6.] #[5. 4. 3. 2.]]))
              (check-equal? (mat-row a 2) #[9. 8. 7. 6.])
              (check-equal? (mat-col a 1) #[2. 6. 8. 4.]))
   (test-case
    "multiply matrices"
    (define a (mat 4 4 #[#[1. 2. 3. 4.] #[5. 6. 7. 8.] #[9. 8. 7. 6.] #[5. 4. 3. 2.]]))
    (define b (mat 4 4 #[#[-2. 1. 2. 3.] #[3. 2. 1. -1.] #[4. 3. 6. 5.] #[1. 2. 7. 8.]]))
    (define c
      (mat 4 4 #[#[20. 22. 50. 48.] #[44. 54. 114. 108.] #[40. 58. 110. 102.] #[16. 26. 46. 42.]]))
    (check-true (mat= (mat* a b) c)))
   (test-case "multiply matrix by vector (tuple)"
              (define a (mat 4 4 #[#[1. 2. 3. 4.] #[2. 4. 4. 2.] #[8. 6. 4. 1.] #[0. 0. 0. 1.]]))
              (define b (tuple 1. 2. 3. 1.))
              (check-tuple= (mat-t* a b) (tuple 18. 24. 33. 1.)))
   (test-case "generate identity matrix" (check-true (mat= (id-mat 4) id-mat-4)))
   (test-case "multiply identity matrix"
              (define a (mat 4 4 #[#[0. 1. 2. 4.] #[1. 2. 4. 8.] #[2. 4. 8. 16.] #[4. 8. 16. 32.]]))
              (check-true (mat= (mat* a id-mat-4) a))
              (define b (tuple 1. 2. 3. 4.))
              (check-tuple= (mat-t* id-mat-4 b) b))
   (test-case "transpose matrices"
              (define a (mat 4 4 #[#[0. 9. 3. 0.] #[9. 8. 0. 8.] #[1. 8. 5. 3.] #[0. 0. 5. 8.]]))
              (define b (mat 4 4 #[#[0. 9. 1. 0.] #[9. 8. 8. 0.] #[3. 0. 5. 5.] #[0. 8. 3. 8.]]))
              (check-true (mat= (transpose a) b))
              (check-true (mat= (transpose b) a))
              (check-true (mat= (transpose id-mat-4) id-mat-4)))))

(define matrix-inversion-test
  (test-suite
   "Matrix Inversion"
   (test-case "find submatrices"
              (define a (mat 3 3 #[#[1. 5. 0.] #[-3. 2. 7.] #[0. 6. -3.]]))
              (define b (mat 2 2 #[#[-3. 2.] #[0. 6.]]))
              (check-true (mat= (submat a 0 2) b))
              (define c (mat 4 4 #[#[-6. 1. 1. 6.] #[-8. 5. 8. 6.] #[-1. 0. 8. 2.] #[-7. 1. -1. 1.]]))
              (define d (mat 3 3 #[#[-6. 1. 6.] #[-8. 8. 6.] #[-7. -1. 1.]]))
              (check-true (mat= (submat c 2 1) d)))
   (test-case "find cofactor"
              (define a (mat 3 3 #[#[3. 5. 0.] #[2. -1. -7.] #[6. -1. 5.]]))
              (check-equal? (cofactor a 0 0) -12.)
              (check-equal? (cofactor a 1 0) -25.))
   (test-case
    "find determinant of larger matrices"
    (define a (mat 3 3 #[#[1. 2. 6.] #[-5. 8. -4.] #[2. 6. 4.]]))
    (check-equal? (cofactor a 0 0) 56.)
    (check-equal? (cofactor a 0 1) 12.)
    (check-equal? (cofactor a 0 2) -46.)
    (check-equal? (det a) -196.)
    (define b (mat 4 4 #[#[-2. -8. 3. 5.] #[-3. 1. 7. 3.] #[1. 2. -9. 6.] #[-6. 7. 7. -9.]]))
    (check-equal? (cofactor b 0 0) 690.)
    (check-equal? (cofactor b 0 1) 447.)
    (check-equal? (cofactor b 0 2) 210.)
    (check-equal? (cofactor b 0 3) 51.)
    (check-equal? (det b) -4071.)
    (define c (mat 4 4 #[#[6. 4. 4. 4.] #[5. 5. 7. 6.] #[4. -9. 3. -7.] #[9. 1. 7. -6.]]))
    (check-equal? (det c) -2120.)
    (define d (mat 4 4 #[#[-4. 2. -2. -3.] #[9. 6. 2. 6.] #[0. -5. 1. -5.] #[0. 0. 0. 0.]]))
    (check-equal? (det d) 0.))
   (test-case
    "inverse matrix test 1"
    (define a (mat 4 4 #[#[-5. 2. 6. -8.] #[1. -5. 1. 8.] #[7. 7. -6. -7.] #[1. -3. 7. 4.]]))
    (define b (inverse a))
    (check-equal? (det a) 532.)
    (check-equal? (cofactor a 2 3) -160.)
    (check-= (mat-entry b 3 2) -160/532 0.00001)
    (check-equal? (cofactor a 3 2) 105.)
    (check-= (mat-entry b 2 3) 105/532 0.00001)
    (define c
      (mat 4
           4
           #[#[0.21805 0.45113 0.24060 -0.04511]
             #[-0.80827 -1.45677 -0.44361 0.52068]
             #[-0.07895 -0.22368 -0.05263 0.19737]
             #[-0.52256 -0.81391 -0.30075 0.30639]]))
    (check-true (mat= b c)))
   (test-case "inverse matrix test 2"
              (define a (mat 4 4 #[#[8. -5. 9. 2.] #[7. 5. 6. 1.] #[-6. 0. 9. 6.] #[-3. 0. -9. -4.]]))
              (define b
                (mat 4
                     4
                     #[#[-0.15385 -0.15385 -0.28205 -0.53846]
                       #[-0.07692 0.12308 0.02564 0.03077]
                       #[0.35897 0.35897 0.43590 0.92308]
                       #[-0.69231 -0.69231 -0.76923 -1.92308]]))
              (check-true (mat= (inverse a) b)))
   (test-case
    "inverse matrix test 3"
    (define a (mat 4 4 #[#[9. 3. 0. 9.] #[-5. -2. -6. -3.] #[-4. 9. 6. 4.] #[-7. 6. 6. 2.]]))
    (define b
      (mat 4
           4
           #[#[-0.04074 -0.07778 0.14444 -0.22222]
             #[-0.07778 0.03333 0.36667 -0.33333]
             #[-0.02901 -0.14630 -0.10926 0.12963]
             #[0.17778 0.06667 -0.26667 0.33333]]))
    (check-true (mat= (inverse a) b)))
   (test-case
    "multiply matrix product by inverse"
    (define a (mat 4 4 #[#[3. -9. 7. 3.] #[3. -8. 2. -9.] #[-4. 4. 4. 1.] #[-6. 5. -1. 1.]]))
    (define b (mat 4 4 #[#[8. 2. 2. 2.] #[3. -1. 7. 0.] #[7. 0. 5. 4.] #[6. -2. 0. 5.]]))
    (define c (mat* a b))
    (define d (mat* c (inverse b)))
    (check-true (mat= a d)))))

(run-tests matrix-test)
(run-tests matrix-inversion-test)
#+END_SRC

* DONE Matrix Transformations
:PROPERTIES:
:ACTIVATED: [2022-08-09]
:END:
** DONE Translation
#+NAME: translate
#+BEGIN_SRC racket :noweb yes
(: translate (-> Float Float Float Matrix))
(define (translate x y z)
  ;; 1 0 0 x
  ;; 0 1 0 y
  ;; 0 0 1 z
  ;; 0 0 0 1
  (build-matrix 4
                4
                (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                  (cond
                    [(= row col) 1.]
                    [(and (= row 0) (= col 3)) x]
                    [(and (= row 1) (= col 3)) y]
                    [(and (= row 2) (= col 3)) z]
                    [else 0.]))))
#+END_SRC

** DONE Scaling
#+NAME: scale
#+BEGIN_SRC racket :noweb yes
(: scale (-> Float Float Float Matrix))
(define (scale x y z)
  ;; x 0 0 0
  ;; 0 y 0 0
  ;; 0 0 z 0
  ;; 0 0 0 1
  (build-matrix 4
                4
                (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                  (cond
                    [(and (= row 0) (= col 0)) x]
                    [(and (= row 1) (= col 1)) y]
                    [(and (= row 2) (= col 2)) z]
                    [(and (= row 3) (= col 3)) 1.]
                    [else 0.]))))
#+END_SRC

** DONE Rotation
#+NAME: rotate
#+BEGIN_SRC racket :noweb yes
(: rotate (-> (U 'x 'y 'z) Float Matrix))
(define (rotate axis rad)
  (cond
    [(eq? axis 'x)
     ;; 1 0      0       0
     ;; 0 cos(r) −sin(r) 0
     ;; 0 sin(r) cos(r)  0
     ;; 0 0      0       1
     (build-matrix 4
                   4
                   (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                     (cond
                       [(and (= row 0) (= col 0)) 1.]
                       [(and (= row 1) (= col 1)) (cos rad)]
                       [(and (= row 1) (= col 2)) (- (sin rad))]
                       [(and (= row 2) (= col 1)) (sin rad)]
                       [(and (= row 2) (= col 2)) (cos rad)]
                       [(and (= row 3) (= col 3)) 1.]
                       [else 0.])))]
    [(eq? axis 'y)
     ;; cos(r)  0 sin(r) 0
     ;; 0       1 0      0
     ;; -sin(r) 0 cos(r) 0
     ;; 0       0 0      1
     (build-matrix 4
                   4
                   (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                     (cond
                       [(and (= row 0) (= col 0)) (cos rad)]
                       [(and (= row 0) (= col 2)) (sin rad)]
                       [(and (= row 1) (= col 1)) 1.]
                       [(and (= row 2) (= col 0)) (- (sin rad))]
                       [(and (= row 2) (= col 2)) (cos rad)]
                       [(and (= row 3) (= col 3)) 1.]
                       [else 0.])))]
    [(eq? axis 'z)
     ;; cos(r) −sin(r) 0 0
     ;; sin(r) cos(r)  0 0
     ;; 0      0       1 0
     ;; 0      0       0 1
     (build-matrix 4
                   4
                   (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                     (cond
                       [(and (= row 0) (= col 0)) (cos rad)]
                       [(and (= row 0) (= col 1)) (- (sin rad))]
                       [(and (= row 1) (= col 0)) (sin rad)]
                       [(and (= row 1) (= col 1)) (cos rad)]
                       [(and (= row 2) (= col 2)) 1.]
                       [(and (= row 3) (= col 3)) 1.]
                       [else 0.])))]))
#+END_SRC

** DONE Shearing
#+NAME: shear
#+BEGIN_SRC racket :noweb yes
(: shear (-> Float Float Float Float Float Float Matrix))
(define (shear dx/y dx/z dy/x dy/z dz/x dz/y)
  ;; 1    dx/y dx/z 0
  ;; dy/x 1    dy/z 0
  ;; dz/x dz/y 1    0
  ;; 0    0    0    1
  (build-matrix 4
                4
                (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                  (cond
                    [(and (= row 0) (= col 0)) 1.]
                    [(and (= row 0) (= col 1)) dx/y]
                    [(and (= row 0) (= col 2)) dx/z]
                    [(and (= row 1) (= col 0)) dy/x]
                    [(and (= row 1) (= col 1)) 1.]
                    [(and (= row 1) (= col 2)) dy/z]
                    [(and (= row 2) (= col 0)) dz/x]
                    [(and (= row 2) (= col 1)) dz/y]
                    [(and (= row 2) (= col 2)) 1.]
                    [(and (= row 3) (= col 3)) 1.]
                    [else 0.]))))
#+END_SRC

** DONE Chaining Transformations
#+NAME: transform
#+BEGIN_SRC racket :noweb yes
(: transformation (-> Matrix * Matrix))
(define (transformation . transformations)
  (: iter (-> (Listof Matrix) Matrix Matrix))
  (define (iter remaining result)
    (if (null? remaining) result (iter (cdr remaining) (mat* (car remaining) result))))
  (iter transformations id-mat-4))

(: transform-pt (-> Point Matrix * Point))
(define (transform-pt pt . transformations)
  (assert (mat-t* (apply transformation transformations) pt) point?))
#+END_SRC

** DONE Putting It Together
#+BEGIN_SRC racket :noweb yes
#lang typed/racket
(require "tuples.rkt")
(require "color.rkt")
(require "canvas-mutable.rkt")
(require "matrix.rkt")

(define c (canvas 25 25))
(define origin (pt 0. 0. 0.))

(let ([center (transform-pt origin (translate 12. 12. 0.))])
  (set-pixel! c
              (assert (exact-round (tuple-x center)) nonnegative-integer?)
              (assert (exact-round (tuple-y center)) nonnegative-integer?)
              (color 1. 1. 0.)))

(define twelve (pt 0. 1. 0.))

(for ([i (in-range 1 13)])
  (let ([hr (transform-pt twelve (rotate 'z (cast (/ (* i pi) 6) Float)) (scale 10. 10. 10.) (translate 12. 12. 0.))])
  (set-pixel! c
              (assert (exact-round (tuple-x hr)) nonnegative-integer?)
              (assert (exact-round (tuple-y hr)) nonnegative-integer?)
              (color 1. 0. 0.))))

(save-canvas c "test.ppm")
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/transform-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../matrix.rkt"
         "../transform.rkt")

<<check-tuple=>>

(define transform-test
  (test-suite
   "Transformations"
   (test-suite "Translation"
               (test-case "Multiplying by a translation matrix"
                          (define t (translate 5. -3. 2.))
                          (define p (pt -3. 4. 5.))
                          (check-tuple= (mat-t* t p) (pt 2. 1. 7.)))
               (test-case "Multiplying by the inverse of a translate matrix"
                          (define t (translate 5. -3. 2.))
                          (define inv (inverse t))
                          (define p (pt -3. 4. 5.))
                          (check-tuple= (mat-t* inv p) (pt -8. 7. 3.)))
               (test-case "Translation does not affect vectors"
                          (define t (translate 5. -3. 2.))
                          (define v (vec -3. 4. 5.))
                          (check-tuple= (mat-t* t v) v)))
   (test-suite "scaling"
               (test-case "A scaling matrix applied to a point"
                          (define t (scale 2. 3. 4.))
                          (define p (pt -4. 6. 8.))
                          (check-tuple= (mat-t* t p) (pt -8. 18. 32.)))
               (test-case "A scaling matrix applied to a vector"
                          (define t (scale 2. 3. 4.))
                          (define v (vec -4. 6. 8.))
                          (check-tuple= (mat-t* t v) (vec -8. 18. 32.)))
               (test-case "Multiplying by the inverse of a scaling matrix"
                          (define t (scale 2. 3. 4.))
                          (define inv (inverse t))
                          (define v (vec -4. 6. 8.))
                          (check-tuple= (mat-t* inv v) (vec -2. 2. 2.)))
               (test-case "Reflection is scaling by a negative value"
                          (define t (scale -1. 1. 1.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt -2. 3. 4.))))
   (test-suite
    "rotation"
    (test-case "Rotating a point around the x axis"
               (define p (pt 0. 1. 0.))
               (define half-quarter (rotate 'x (/ pi 4)))
               (define full-quarter (rotate 'x (/ pi 2)))
               (check-tuple= (mat-t* half-quarter p)
                             (pt 0. (cast (/ (sqrt 2) 2) Float) (cast (/ (sqrt 2) 2) Float)))
               (check-tuple= (mat-t* full-quarter p) (pt 0. 0. 1.)))
    (test-case "The inverse of an x-rotation rotates in the opposite direction"
               (define p (pt 0. 1. 0.))
               (define half-quarter (rotate 'x (/ pi 4)))
               (define inv (inverse half-quarter))
               (check-tuple= (mat-t* inv p)
                             (pt 0. (cast (/ (sqrt 2) 2) Float) (cast (- (/ (sqrt 2) 2)) Float))))
    (test-case "Rotating a point around the y axis"
               (define p (pt 0. 0. 1.))
               (define half-quarter (rotate 'y (/ pi 4)))
               (define full-quarter (rotate 'y (/ pi 2)))
               (check-tuple= (mat-t* half-quarter p)
                             (pt (cast (/ (sqrt 2) 2) Float) 0. (cast (/ (sqrt 2) 2) Float)))
               (check-tuple= (mat-t* full-quarter p) (pt 1. 0. 0.)))
    (test-case "Rotating a point around the z axis"
               (define p (pt 0. 1. 0.))
               (define half-quarter (rotate 'z (/ pi 4)))
               (define full-quarter (rotate 'z (/ pi 2)))
               (check-tuple= (mat-t* half-quarter p)
                             (pt (cast (- (/ (sqrt 2) 2)) Float) (cast (/ (sqrt 2) 2) Float) 0.))
               (check-tuple= (mat-t* full-quarter p) (pt -1. 0. 0.))))
   (test-suite "shearing"
               (test-case "A shearing transformation moves x in proportion to y"
                          (define t (shear 1. 0. 0. 0. 0. 0.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt 5. 3. 4.)))
               (test-case "A shearing transformation moves x in proportion to z"
                          (define t (shear 0. 1. 0. 0. 0. 0.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt 6. 3. 4.)))
               (test-case "A shearing transformation moves y in proportion to x"
                          (define t (shear 0. 0. 1. 0. 0. 0.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt 2. 5. 4.)))
               (test-case "A shearing transformation moves y in proportion to z"
                          (define t (shear 0. 0. 0. 1. 0. 0.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt 2. 7. 4.)))
               (test-case "A shearing transformation moves z in proportion to x"
                          (define t (shear 0. 0. 0. 0. 1. 0.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt 2. 3. 6.)))
               (test-case "A shearing transformation moves z in proportion to y"
                          (define t (shear 0. 0. 0. 0. 0. 1.))
                          (define p (pt 2. 3. 4.))
                          (check-tuple= (mat-t* t p) (pt 2. 3. 7.))))
   (test-suite "chained transformations"
               (test-case "Chained transformations must be applied in reverse order"
                 (define p (pt 1. 0. 1.))
                 (define A (rotate 'x (/ pi 2)))
                 (define B (scale 5. 5. 5.))
                 (define C (translate 10. 5. 7.))
                 (check-tuple= (transform-pt p A B C) (pt 15. 0. 7.))))))

(run-tests transform-test)
#+END_SRC

* DONE Ray-Sphere Intersections
:PROPERTIES:
:ACTIVATED: [2022-08-10]
:COMPLETED: [2022-08-11]
:END:
** DONE Creating Rays
:PROPERTIES:
:ACTIVATED: [2022-08-10]
:COMPLETED: [2022-08-10]
:END:
#+NAME: ray-base
#+BEGIN_SRC racket :noweb yes
(struct ray ([origin : Point] [direction : Vector]) #:prefab #:type-name Ray)

(: pos (-> Ray Float Point))
(define (pos ray t)
  (assert (tuple+ (ray-origin ray) (tuple* (ray-direction ray) t)) point?))
#+END_SRC

** DONE Intersecting Rays with Spheres
:PROPERTIES:
:ACTIVATED: [2022-08-10]
:COMPLETED: [2022-08-10]
:END:

#+BEGIN_SRC racket :noweb yes
(struct shape ([id : String] [transformation : Matrix] [material : Material]) #:prefab #:type-name Shape)
(struct _sphere shape () #:prefab #:type-name Sphere)

(: sphere (->* (String) (#:transformation Matrix #:material Material) Shape))
(define (sphere id #:transformation [transformation id-mat-4] #:material [material (make-material)])
  (_sphere id transformation material))
#+END_SRC

*** DONE Tracking Intersections
:PROPERTIES:
:ACTIVATED: [2022-08-10]
:COMPLETED: [2022-08-10]
:END:
#+NAME: intersection
#+BEGIN_SRC racket :noweb yes
(struct intersection ([t : Float] [obj : Shape]) #:prefab #:type-name Intersection)
#+END_SRC

Refactored in [[*Building & Rendering a World]]

#+BEGIN_SRC racket :noweb yes
(: intersect (-> Shape Ray (Listof Intersection)))
(define (intersect shape ray)
  (let* ([ray : Ray (transform-ray ray (inverse (shape-transformation shape)))]
         [center-to-ray : Vector (assert (tuple- (ray-origin ray) (pt 0. 0. 0.)) vect?)]
         [a : Float (dot* (ray-direction ray) (ray-direction ray))]
         [b : Float (* 2 (dot* (ray-direction ray) center-to-ray))]
         [c : Float (- (dot* center-to-ray center-to-ray) 1)]
         [discriminant : Float (- (sqr b) (* 4. a c))]
         [solution : (-> (U '+ '-) Float)
          (lambda (sign)
            (cast (/ ((if (eq? sign '-) - +) (- b) (sqrt discriminant)) (* 2 a)) Float))])
    (if (< discriminant 0.)
        '()
        (list (intersection (solution '-) shape) (intersection (solution '+) shape)))))
#+END_SRC

** DONE Identifying Hits
:PROPERTIES:
:ACTIVATED: [2022-08-10]
:COMPLETED: [2022-08-10]
:END:
Just returning the intersection with the smallest nonnegative ~t~:
#+NAME: hit
#+BEGIN_SRC racket :noweb yes
(: hit (-> (Listof Intersection) (U Intersection Null)))
(define (hit intersections)
  (: iter (-> (Listof Intersection) Intersection (U Intersection Null)))
  (define (iter remaining result)
    (if (null? remaining)
        (if (= (intersection-t result) +inf.0) null result)
        (iter (cdr remaining)
              (if (and (>= (intersection-t (car remaining)) 0.)
                       (< (intersection-t (car remaining)) (intersection-t result)))
                  (car remaining)
                  result))))
  (iter intersections (intersection +inf.0 (sphere "placeholder"))))

(: fast-hit (-> (Listof Intersection) (U Intersection Null)))
  (define (fast-hit intersections)
    (cond
      [(null? intersections) null]
      [(>= (intersection-t (car intersections)) 0.) (car intersections)]
      [else (fast-hit (cdr intersections))]))
#+END_SRC

~fast-hit~ returns the first intersection with nonnegative ~t~ for when the intersections are known sorted.

** DONE Transforming Rays and Spheres
:PROPERTIES:
:ACTIVATED: [2022-08-10]
:COMPLETED: [2022-08-11]
:END:
Converting the ray's origin and direction in world space to in object space, by multiplying the inverse of the object's transformation matrix.
#+NAME: transform-ray
#+BEGIN_SRC racket :noweb yes
(: transform-ray (-> Ray Matrix * Ray))
(define (transform-ray r . transformations)
  (ray (assert (mat-t* (apply transformation transformations) (ray-origin r)) point?)
       (assert (mat-t* (apply transformation transformations) (ray-direction r)) vect?)))
#+END_SRC

Note that ~struct-copy~ is kind of broken, especially when dealing with subtypes:
- https://stackoverflow.com/questions/52142731/how-do-you-get-struct-copy-to-create-a-struct-of-the-same-type-as-the-original
- https://github.com/racket/typed-racket/issues/930
- https://github.com/racket/racket/issues/1399

I tried something like this:

#+BEGIN_SRC racket :noweb yes
(define-syntax (set-transformation type val trans)
  (struct-copy type val [transformation #:parent shape trans]))
#+END_SRC

but it seems like type information is not available at marcro expansion; attempts to make it a function have also failed; in the end I opted for something really really silly:

#+BEGIN_SRC racket :noweb yes
(: set-transformation
   (-> (->* (String) (#:transformation Matrix #:material Material) Shape) Shape Matrix Shape))
(define (set-transformation constructor val trans)
  (constructor (shape-id val) #:transformation trans #:material (shape-material val)))
#+END_SRC

** DONE Putting It Together
:PROPERTIES:
:ACTIVATED: [2022-08-11]
:COMPLETED: [2022-08-11]
:END:
#+BEGIN_SRC racket :noweb yes
(define ray-origin (pt 0. 0. -5.))
(define wall-z 10.)
(define wall-size 10.)
(define half (/ wall-size 2))
(define canvas-pixels 100)
(define pixel-size (/ wall-size canvas-pixels))

(define c (canvas canvas-pixels canvas-pixels))
(define s (sphere "unit sphere"))

(for* ([y (in-range (canvas-width c))] [x (in-range (canvas-height c))])
  (let* ([world-y (- half (* y pixel-size))]
         [world-x (+ (- half) (* x pixel-size))]
         [target (pt world-x world-y wall-z)]
         [r (ray ray-origin (norm (assert (tuple- target ray-origin) vect?)))]
         [xs (intersect s r)])
    (set-pixel! c
                (assert x nonnegative-integer?)
                (assert y nonnegative-integer?)
                (if (null? xs) (color 1. 1. 1.) (color 1. 0. 0.)))))

(save-canvas c "ray-sphere intersection.ppm")
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle no
#lang typed/racket
(provide (all-defined-out))
(require "tuples.rkt")
(require "matrix.rkt")
(require "transform.rkt")
(require "ray.rkt")

<<intersect>>

<<intersection>>

<<hit>>
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle no
#lang typed/racket
(provide (all-defined-out))
(require "matrix.rkt")

<<shapes-base>>

<<set-transformation>>
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/ray-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../matrix.rkt"
         "../transform.rkt"
         "../ray.rkt"
         "../intersect.rkt"
         "../shapes.rkt")

<<check-tuple=>>

(define ray-intersection-test
  (test-suite
   "Ray-Sphere Intersections"
   (test-suite "Creating Rays"
               (test-case "Creating and querying a ray"
                          (define origin (pt 1. 2. 3.))
                          (define direction (vec 4. 5. 6.))
                          (define r (ray origin direction))
                          (check-tuple= (ray-origin r) origin)
                          (check-tuple= (ray-direction r) direction))
               (test-case "Computing a point from a distance"
                          (define r (ray (pt 2. 3. 4.) (vec 1. 0. 0.)))
                          (check-tuple= (pos r 0.) (pt 2. 3. 4.))
                          (check-tuple= (pos r 1.) (pt 3. 3. 4.))
                          (check-tuple= (pos r -1.) (pt 1. 3. 4.))
                          (check-tuple= (pos r 2.5) (pt 4.5 3. 4.))))
   (test-suite "Intersecting Rays with Spheres"
               (test-case "A ray intersects a sphere at two points"
                          (define r (ray (pt 0. 0. -5.) (vec 0. 0. 1.)))
                          (define s (sphere "s"))
                          (define xs (intersect s r))
                          (check-equal? xs (list (intersection 4. s) (intersection 6. s))))
               (test-case "A ray intersects a sphere at a tangent"
                          (define r (ray (pt 0. 1. -5.) (vec 0. 0. 1.)))
                          (define s (sphere "s"))
                          (define xs (intersect s r))
                          (check-equal? xs (list (intersection 5. s) (intersection 5. s))))
               (test-case "A ray misses a sphere"
                          (define r (ray (pt 0. 2. -5.) (vec 0. 0. 1.)))
                          (define s (sphere "s"))
                          (define xs (intersect s r))
                          (check-equal? xs '()))
               (test-case "A ray originates inside a sphere"
                          (define r (ray (pt 0. 0. 0.) (vec 0. 0. 1.)))
                          (define s (sphere "s"))
                          (define xs (intersect s r))
                          (check-equal? xs (list (intersection -1. s) (intersection 1. s))))
               (test-case "A sphere is behind a ray"
                          (define r (ray (pt 0. 0. 5.) (vec 0. 0. 1.)))
                          (define s (sphere "s"))
                          (define xs (intersect s r))
                          (check-equal? xs (list (intersection -6. s) (intersection -4. s)))))
   (test-suite "Tracking Intersections"
               (test-case "An intersection encapsulates t and object"
                          (define s (sphere "s"))
                          (define i (intersection 3.5 s))
                          (check-equal? (intersection-t i) 3.5)
                          (check-equal? (intersection-obj i) s))
               (test-case "Intersect sets the object on the intersection"
                          (define r (ray (pt 0. 0. -5.) (vec 0. 0. 1.)))
                          (define s (sphere "s"))
                          (define xs (intersect s r))
                          (check-equal? (length xs) 2)
                          (check-equal? (intersection-obj (list-ref xs 0)) s)
                          (check-equal? (intersection-obj (list-ref xs 1)) s)))
   (test-suite "Identifying Hits"
               (test-case "The hit, when all intersections have positive t"
                          (define s (sphere "s"))
                          (define i1 (intersection 1. s))
                          (define i2 (intersection 2. s))
                          (define xs (list i2 i1))
                          (check-equal? (hit xs) i1))
               (test-case "The hit, when some intersections have negative t"
                          (define s (sphere "s"))
                          (define i1 (intersection -1. s))
                          (define i2 (intersection 1. s))
                          (define xs (list i2 i1))
                          (check-equal? (hit xs) i2))
               (test-case "The hit, when all intersections have negative t"
                          (define s (sphere "s"))
                          (define i1 (intersection -2. s))
                          (define i2 (intersection -1. s))
                          (define xs (list i2 i1))
                          (check-equal? (hit xs) null))
               (test-case "The hit is always the lowest nonnegative intersection"
                          (define s (sphere "s"))
                          (define i1 (intersection 5. s))
                          (define i2 (intersection 7. s))
                          (define i3 (intersection -3. s))
                          (define i4 (intersection 2. s))
                          (define xs (list i1 i2 i3 i4))
                          (check-equal? (hit xs) i4)))
   (test-suite "Transforming Rays and Spheres"
               (test-case "Translating a ray"
                          (define r (ray (pt 1. 2. 3.) (vec 0. 1. 0.)))
                          (define m (translate 3. 4. 5.))
                          (define r2 (transform-ray r m))
                          (check-equal? r2 (ray (pt 4. 6. 8.) (vec 0. 1. 0.))))
               (test-case "Scaling a ray"
                          (define r (ray (pt 1. 2. 3.) (vec 0. 1. 0.)))
                          (define m (scale 2. 3. 4.))
                          (define r2 (transform-ray r m))
                          (check-equal? r2 (ray (pt 2. 6. 12.) (vec 0. 3. 0.))))
               (test-case "A sphere's default transformation"
                          (define s (sphere "s"))
                          (check-equal? (shape-transformation s) id-mat-4))
               (test-case "Changing (actually not) a sphere's transformation"
                          (define s (sphere "s"))
                          (define t (translate 2. 3. 4.))
                          (define s2 (set-transformation sphere s t))
                          (check-equal? (shape-transformation s2) t))
               (test-case "Intersecting a scaled sphere with a ray"
                 (define r (ray (pt 0. 0. -5.) (vec 0. 0. 1.)))
                 (define s (sphere "s" #:transformation (scale 2. 2. 2.)))
                 (define xs (intersect s r))
                 (check-equal? xs (list (intersection 3. s) (intersection 7. s))))
               (test-case "Intersecting a translated sphere with a ray"
                 (define r (ray (pt 0. 0. -5.) (vec 0. 0. 1.)))
                 (define s (sphere "s" #:transformation (translate 5. 0. 0.)))
                 (define xs (intersect s r))
                 (check-equal? xs '())))))

(run-tests ray-intersection-test)
#+END_SRC

* DONE Light and Shading
:PROPERTIES:
:ACTIVATED: [2022-08-11]
:COMPLETED: [2022-08-13]
:END:
- eye vector: negate ray direction
- light vector: light source - intersection
- surface normal
- reflection vector: reflect across normal

** DONE Surface Normals
:PROPERTIES:
:ACTIVATED: [2022-08-12]
:COMPLETED: [2022-08-12]
:END:

 An excellent explanation: https://stackoverflow.com/questions/13654401/why-transform-normals-with-the-transpose-of-the-inverse-of-the-modelview-matrix
  
#+BEGIN_SRC racket :noweb yes
(: normal-at (-> Shape Point Vector))
(define (normal-at sphere world-point)
  (let* ([trans : Matrix (shape-transformation sphere)]
         [obj-pt : Point (assert (mat-t* (inverse trans) world-point) point?)]
         [obj-norm : Vector (assert (tuple- obj-pt (pt 0. 0. 0.)) vect?)]
         [world-norm : Tuple (mat-t* (transpose (inverse trans)) obj-norm)])
    (norm (vec (tuple-x world-norm) (tuple-y world-norm) (tuple-z world-norm)))))
#+END_SRC

Currently only handles spheres as do everything else.

** DONE Reflecting Vectors
:PROPERTIES:
:ACTIVATED: [2022-08-12]
:COMPLETED: [2022-08-12]
:END:
#+NAME: reflect
#+BEGIN_SRC racket :noweb yes
(: reflect (-> Vector Vector Vector))
(define (reflect in normal)
  (assert (tuple- in (tuple* normal (* 2 (dot* in normal)))) vect?))
#+END_SRC

** DONE The Phong Reflection Model
:PROPERTIES:
:ACTIVATED: [2022-08-12]
:COMPLETED: [2022-08-13]
:END:
3 types of lighting:
- ambient reflection (constant)
- diffuse reflection (depends on the angle between the light source and the surface normal)
- specular reflection (depends the the angle between the reflection vector and the eye vector)

#+NAME: light
#+BEGIN_SRC racket :noweb yes
(struct light ([id : String] [position : Point] [intensity : Color]) #:prefab #:type-name Light)
(struct point-light light () #:prefab #:type-name PointLight)
#+END_SRC

#+BEGIN_SRC racket :noweb yes
(struct material
        ([color : Color] [ambient : Float] [diffuse : Float] [specular : Float] [shininess : Float])
  #:prefab
  #:type-name Material)

(:
 make-material
 (->* () (#:color Color #:ambient Float #:diffuse Float #:specular Float #:shininess Float) Material))
(define (make-material #:color [color (color 1. 1. 1.)]
                          #:ambient [ambient 0.1]
                          #:diffuse [diffuse 0.9]
                          #:specular [specular 0.9]
                          #:shininess [shininess 200.])
  (material color ambient diffuse specular shininess))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
(: set-material
   (-> (->* (String) (#:transformation Matrix #:material Material) Shape) Shape Material Shape))
(define (set-material constructor val material)
  (constructor (shape-id val) #:transformation (shape-transformation val) #:material material))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
(: phong (->* (Material Light Point Vector Vector) (Boolean) Color))
(define (phong material light point eyev normalv [in-shadow #f])
  (let* ([blended : Color
          (color* (material-color material) (light-intensity light))]
         [ambient : Color
          (color* blended (material-ambient material))]
         [lightv : Vector
          (norm (assert (tuple- (light-position light) point) vect?))]
         [*light-normal : Float (dot* lightv normalv)]
         [diffuse : Color
          (if (< *light-normal 0.)
              black
              (color* blended (* (material-diffuse material) *light-normal)))]
         [specular : Color
          (if (< *light-normal 0.)
              black
              (let* ([reflectv : Vector
                      (reflect (assert (-tuple lightv) vect?) normalv)]
                     [*reflect-eye : Float (dot* reflectv eyev)])
                (if (< *reflect-eye 0.)
                    black
                    (color* (light-intensity light)
                            (* (material-specular material)
                               (cast (expt *reflect-eye (material-shininess material)) Float))))))])
    (if in-shadow
        ambient
        (colors+ ambient diffuse specular))))
#+END_SRC

** DONE Putting It Together
:PROPERTIES:
:ACTIVATED: [2022-08-13]
:COMPLETED: [2022-08-13]
:END:
#+BEGIN_SRC racket :noweb yes
(define ray-origin (pt 0. 0. -5.))
(define wall-z 10.)
(define wall-size 10.)
(define half (/ wall-size 2))
(define canvas-pixels 200)
(define pixel-size (/ wall-size canvas-pixels))

(define c (canvas canvas-pixels canvas-pixels))
(define s (sphere "unit sphere" #:material (make-material #:color (color 1. 0. 0.))))
(define light (point-light (pt -10. 10. -10.) (color 1. 1. 1.)))

(for* ([y : Integer (in-range (canvas-width c))] [x : Integer (in-range (canvas-height c))])
  (let* ([world-y : Float (- half (* (exact->inexact y) pixel-size))]
         [world-x : Float (+ (- half) (* (exact->inexact x) pixel-size))]
         [target (pt world-x world-y wall-z)]
         [r (ray ray-origin (norm (assert (tuple- target ray-origin) vect?)))]
         [xs (intersect s r)]
         [hit (hit xs)])
    (set-pixel! c
                (assert x nonnegative-integer?)
                (assert y nonnegative-integer?)
                (if (or (null? xs) (null? hit))
                    (color 1. 1. 1.)
                    (let* ([point (pos r (intersection-t hit))]
                           [object (intersection-obj hit)]
                           [normal (normal-at object point)]
                           [eye (assert (-tuple (ray-direction r)) vect?)])
                      (phong (shape-material object) light point eye normal))))))

(save-canvas c "ray-sphere intersection.ppm")
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle no
#lang typed/racket
(provide (all-defined-out))
(require "tuples.rkt")
(require "color.rkt")
(require "matrix.rkt")
(require "material.rkt")
(require "shapes.rkt")

<<light>>

<<reflect>>

<<normal-at>>

<<phong>>
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle no
#lang typed/racket
(provide (all-defined-out))
(require "tuples.rkt")
(require "matrix.rkt")
(require "color.rkt")
(require "material.rkt")

<<shapes-base>>

<<set-transformation>>

<<set-material>>
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/light-shading-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../color.rkt"
         "../matrix.rkt"
         "../transform.rkt"
         "../ray.rkt"
         "../intersect.rkt"
         "../light.rkt"
         "../shading.rkt"
         "../material.rkt"
         "../shapes.rkt")

<<check-tuple=>>

<<check-color=>>

(define light-and-shading-test
  (test-suite
   "Light and Shading"
   (test-suite
    "Surface Normals"
    (test-case "The normal on a sphere at a point on the x axis"
               (define s (sphere "s"))
               (define n (normal-at s (pt 1. 0. 0.)))
               (check-tuple= n (vec 1. 0. 0.)))
    (test-case "The normal on a sphere at a point on the y axis"
               (define s (sphere "s"))
               (define n (normal-at s (pt 0. 1. 0.)))
               (check-tuple= n (vec 0. 1. 0.)))
    (test-case "The normal on a sphere at a point on the z axis"
               (define s (sphere "s"))
               (define n (normal-at s (pt 0. 0. 1.)))
               (check-tuple= n (vec 0. 0. 1.)))
    (test-case "The normal on a sphere at a nonaxial point"
               (define s (sphere "s"))
               (define n (normal-at s (pt (/ (sqrt 3) 3.) (/ (sqrt 3) 3.) (/ (sqrt 3) 3.))))
               (check-tuple= n (vec (/ (sqrt 3) 3.) (/ (sqrt 3) 3.) (/ (sqrt 3) 3.))))
    (test-case "The normal is a normalized vector"
               (define s (sphere "s"))
               (define n (normal-at s (pt 1. 0. 0.)))
               (check-tuple= n (norm n)))
    (test-case "Computing the normal on a translated sphere"
               (define s (sphere "s" #:transformation (translate 0. 1. 0.)))
               (define n (normal-at s (pt 0. 1.70711 -0.70711)))
               (check-tuple= n (vec 0. 0.70711 -0.70711)))
    (test-case
     "Computing the normal on a transformed sphere"
     (define s (sphere "s" #:transformation (transformation (rotate 'z (/ pi 5)) (scale 1. 0.5 1.))))
     (define n (normal-at s (pt 0. (/ (sqrt 2.) 2.) (- (/ (sqrt 2.) 2.)))))
     (check-tuple= n (vec 0. 0.97014 -0.24254))))
   (test-suite "Reflection Vectors"
               (test-case "Reflection a vector approaching at 45 deg"
                          (define v (vec 1. -1. 0.))
                          (define n (vec 0. 1. 0.))
                          (define r (reflect v n))
                          (check-tuple= r (vec 1. 1. 0.)))
               (test-case "Reflecting a vector off a slanted surface"
                          (define v (vec 0. -1. 0.))
                          (define n (vec (/ (sqrt 2.) 2.) (/ (sqrt 2.) 2.) 0.))
                          (define r (reflect v n))
                          (check-tuple= r (vec 1. 0. 0.))))
   (test-suite
    "The Phong Reflection Model"
    (test-case "A point light has a position and intensity"
               (define intensity (color 1. 1. 1.))
               (define position (pt 0. 0. 0.))
               (define light (point-light "l" position intensity))
               (check-equal? (light-position light) position)
               (check-equal? (light-intensity light) intensity))
    (test-case "The default material"
               (define m (make-material))
               (check-equal? (material-color m) (color 1. 1. 1.))
               (check-equal? (material-ambient m) 0.1)
               (check-equal? (material-diffuse m) 0.9)
               (check-equal? (material-specular m) 0.9)
               (check-equal? (material-shininess m) 200.))
    ;; (test-case "A sphere has a default material"
    ;;            (define s (sphere "s"))
    ;;            (check-equal? (shape-material s) (make-material)))
    (test-case "A sphere may be assigned a material"
               (define s (sphere "s" #:material (make-material #:ambient 1.)))
               (check-equal? (material-ambient (shape-material s)) 1.))
    (let ([m (make-material)] [pos (pt 0. 0. 0.)] [s (sphere "s")])
      (test-case "Lighting with the eye between the light and the surface"
                 (define eyev (vec 0. 0. -1.))
                 (define normalv (vec 0. 0. -1.))
                 (define light (point-light "l" (pt 0. 0. -10.) (color 1. 1. 1.)))
                 (check-color= (phong m s light pos eyev normalv) (color 1.9 1.9 1.9)))
      (test-case "Lighting with the eye between the light and the surface, eye offset 45 deg"
                 (define eyev (vec 0. (/ (sqrt 2.) 2.) (- (/ (sqrt 2.) 2.))))
                 (define normalv (vec 0. 0. -1.))
                 (define light (point-light "l" (pt 0. 0. -10.) (color 1. 1. 1.)))
                 (check-color= (phong m s light pos eyev normalv) (color 1.0 1.0 1.0)))
      (test-case "Lighting with eye opposite surface, light offset 45 deg"
                 (define eyev (vec 0. 0. -1.))
                 (define normalv (vec 0. 0. -1.))
                 (define light (point-light "l" (pt 0. 10. -10.) (color 1. 1. 1.)))
                 (check-color= (phong m s light pos eyev normalv) (color 0.7364 0.7364 0.7364)))
      (test-case "Lighting with eye in the path of the reflection vector"
                 (define eyev (vec 0. (- (/ (sqrt 2.) 2.)) (- (/ (sqrt 2.) 2.))))
                 (define normalv (vec 0. 0. -1.))
                 (define light (point-light "l" (pt 0. 10. -10.) (color 1. 1. 1.)))
                 (check-color= (phong m s light pos eyev normalv) (color 1.6364 1.6364 1.6364)))
      (test-case "Lighting with the light behind the surface"
                 (define eyev (vec 0. 0. -1.))
                 (define normalv (vec 0. 0. -1.))
                 (define light (point-light "l" (pt 0. 0. 10.) (color 1. 1. 1.)))
                 (check-color= (phong m s light pos eyev normalv) (color 0.1 0.1 0.1)))))))

(run-tests light-and-shading-test)
#+END_SRC

* DONE Making a Scene
:PROPERTIES:
:ACTIVATED: [2022-08-13]
:COMPLETED: [2022-08-18]
:END:
** DONE Building & Rendering a World
:PROPERTIES:
:ACTIVATED: [2022-08-13]
:COMPLETED: [2022-08-17]
:END:

Let's use hash tables because I also want to try them out:
#+NAME: world-base
#+BEGIN_SRC racket :noweb yes
(struct world
        ([objects : (Immutable-HashTable String Shape)] [lights : (Immutable-HashTable String Light)])
  #:prefab
  #:type-name World)

(: add-objects (-> World Shape * World))
(define (add-objects w . objects)
  (for/fold ([objs : (Immutable-HashTable String Shape) (world-objects w)]
             #:result (world objs (world-lights w)))
            ([obj (in-list objects)])
    (hash-set objs (shape-id obj) obj)))

(: add-lights (-> World Light * World))
(define (add-lights w . lights)
  (for/fold ([luces : (Immutable-HashTable String Light) (world-lights w)]
             #:result (world (world-objects w) luces))
            ([lux (in-list lights)])
    (hash-set luces (light-id lux) lux)))

(: make-world (->* () ((Listof Shape) (Listof Light)) World))
(define (make-world [objects '()] [lights '()])
  (let ([empty : World (world (make-immutable-hash) (make-immutable-hash))])
    (apply add-objects (apply add-lights empty lights) objects)))

(define default-world
  (make-world
   (list (sphere "outer concentric sphere"
                 #:material (make-material #:color (color 0.8 1.0 0.6) #:diffuse 0.7 #:specular 0.2))
         (sphere "inner concentric sphere" #:transformation (scale 0.5 0.5 0.5)))
   (list (point-light "default light" (pt -10. 10. -10.) (color 1. 1. 1.)))))
#+END_SRC

#+NAME: intersect-world
#+BEGIN_SRC racket :noweb yes
(: intersect-world (-> World Ray (Listof Intersection)))
(define (intersect-world world ray)
  (for/fold ([intersections : (Listof Intersection) '()]
             #:result ((inst sort Intersection) intersections #:key intersection-t <=))
            ([obj (in-hash-values (world-objects world))])
    (append intersections (intersect obj ray))))
#+END_SRC

This is beautiful...if it could infer types more.

#+BEGIN_SRC racket :noweb yes
(struct intersection-data
        ([t : Float] [object : Shape]
                     [point : Point]
                     [eyev : Vector]
                     [normalv : Vector]
                     [inside : Boolean]
                     [over-pt : Point])
  #:prefab
  #:type-name IntersectionData)

(: precomp (-> Intersection Ray IntersectionData))
(define (precomp intersection ray)
  (let* ([t (intersection-t intersection)]
         [object (intersection-obj intersection)]
         [point (pos ray t)]
         [eyev (assert (-tuple (ray-direction ray)) vect?)]
         [normalv (normal-at object point)]
         [-normalv (assert (-tuple normalv) vect?)]
         [inside (if (< (dot* normalv eyev) 0.) #t #f)]
         [adjusted-normalv (if inside -normalv normalv)]
         [over-pt (assert (tuple+ point (tuple* adjusted-normalv EPSILON)) point?)])
    (intersection-data t object point eyev adjusted-normalv inside over-pt)))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
(: shade-intersection (-> World IntersectionData Color))
(define (shade-intersection world comps)
  (let ([per-light-shading
         :
         (Listof Color)
         (for/list ([light : Light (in-hash-values (world-lights world))])
           (phong (shape-material (intersection-data-object comps))
                  (intersection-data-object comps)
                  light
                  (intersection-data-point comps)
                  (intersection-data-eyev comps)
                  (intersection-data-normalv comps)
                  (is-shadowed world light (intersection-data-over-pt comps))))])
    (apply colors+ per-light-shading)))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
(: shade-ray (-> World Ray Color))
(define (shade-ray world ray)
  (let* ([intersections : (Listof Intersection) (intersect-world world ray)]
         ;; sorted intersections
         [hit : (U Intersection Null) (fast-hit intersections)])
    (if (null? hit)
        black
        (let* ([precomp : IntersectionData (precomp hit ray)]
               [shade : Color (shade-intersection world precomp)])
          shade))))
#+END_SRC

** DONE Defining a View Transformation
:PROPERTIES:
:ACTIVATED: [2022-08-17]
:COMPLETED: [2022-08-17]
:END:
#+NAME: view-transformation
#+BEGIN_SRC racket :noweb yes
(: view-transformation (-> Point Point Vector Matrix))
(define (view-transformation from to up)
  (let* ([forward : Vector (norm (assert (tuple- to from) vect?))]
         [left : Vector (cross* forward (norm up))]
         [true-up : Vector (cross* left forward)]
         [orientation : Matrix
          (build-matrix 4
                        4
                        (lambda ([row : Exact-Nonnegative-Integer] [col : Exact-Nonnegative-Integer])
                          (cond
                            [(and (= row 0) (= col 0)) (tuple-x left)]
                            [(and (= row 0) (= col 1)) (tuple-y left)]
                            [(and (= row 0) (= col 2)) (tuple-z left)]
                            [(and (= row 1) (= col 0)) (tuple-x true-up)]
                            [(and (= row 1) (= col 1)) (tuple-y true-up)]
                            [(and (= row 1) (= col 2)) (tuple-z true-up)]
                            [(and (= row 2) (= col 0)) (- (tuple-x forward))]
                            [(and (= row 2) (= col 1)) (- (tuple-y forward))]
                            [(and (= row 2) (= col 2)) (- (tuple-z forward))]
                            [(and (= row 3) (= col 3)) 1.]
                            [else 0.])))])
    (mat* orientation (translate (- (tuple-x from)) (- (tuple-y from)) (- (tuple-z from))))))
#+END_SRC

** DONE Implementing a Camera
:PROPERTIES:
:ACTIVATED: [2022-08-17]
:COMPLETED: [2022-08-18]
:END:
#+NAME: camera-base
#+BEGIN_SRC racket :noweb yes
(struct camera
        ([hsize : Exact-Positive-Integer] [vsize : Exact-Positive-Integer]
                                             [fov : Float]
                                             [transform : Matrix]
                                             [focal-length : Float]
                                             [aparture-size : Float])
  #:prefab
  #:type-name Camera)

(: make-camera
   (->* (#:hsize Exact-Positive-Integer #:vsize Exact-Positive-Integer #:fov Float)
        (#:transform Matrix #:focal-length Float #:aparture-size Float)
        Camera))
(define (make-camera #:hsize hsize
                     #:vsize vsize
                     #:fov fov
                     #:transform [transform id-mat-4]
                     #:focal-length [focal-length 1.]
                     #:aparture-size [aparture-size 0.002])
  (camera hsize vsize fov transform focal-length aparture-size))

(: camera-half-width-height (-> Camera (Pair Float Float)))
(define (camera-half-width-height c)
  (let* ([half-view : Float (* (camera-focal-length c) (tan (/ (camera-fov c) 2.)))]
         [aspect : Float (/ (exact->inexact (camera-hsize c)) (exact->inexact (camera-vsize c)))]
         [half-width : Float (if (>= aspect 1.) half-view (* half-view aspect))]
         [half-height : Float (if (>= aspect 1.) (/ half-view aspect) half-view)])
    (cons (cast half-width Float) (cast half-height Float))))

(: camera-pixel-size (-> Camera Float))
(define (camera-pixel-size c)
  (let* ([half-width-height (camera-half-width-height c)])
    (/ (* 2. (car half-width-height)) (exact->inexact (camera-hsize c)))))
#+END_SRC

#+NAME: rays-to-pixel
#+BEGIN_SRC racket :noweb yes
(: rays-to-pixel
   (->* (Camera Exact-Nonnegative-Integer Exact-Nonnegative-Integer)
        (Exact-Positive-Integer)
        (Listof Ray)))
(define (rays-to-pixel c x y [nrays 1])
  (let* ([pixel-size (camera-pixel-size c)]
         [x-offset (* (+ (exact->inexact x) 0.5) pixel-size)]
         [y-offset (* (+ (exact->inexact y) 0.5) pixel-size)]
         [half-width-height (camera-half-width-height c)]
         [world-x (- (car half-width-height) x-offset)]
         [world-y (- (cdr half-width-height) y-offset)]
         [pixel (mat-t* (inverse (camera-transform c))
                        (pt world-x world-y (- (camera-focal-length c))))])
    (: make-ray (-> Point Ray))
    (define (make-ray origin)
      (let* ([transformed-origin (assert (mat-t* (inverse (camera-transform c)) origin) point?)]
             [direction (norm (assert (tuple- pixel transformed-origin) vect?))])
        (ray transformed-origin direction)))
    (for/fold ([rays : (Listof Ray) '()])
              ([i (in-range 0 nrays)])
      (if (= i 0)
          ((inst cons Ray) (make-ray (pt 0. 0. 0.)) rays)
          (let* ([random (random randgen)]
                 [sign (if (> random 0.5) + -)]
                 [offset (sign (* random (camera-aparture-size c)))])
            ((inst cons Ray) (make-ray (pt offset offset 0.)) rays))))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
(: render (->* (World Camera) (Exact-Positive-Integer) Canvas))
(define (render w c [nrays 1])
  (build-canvas (camera-hsize c)
                (camera-vsize c)
                (lambda (x y)
                  (let* ([rays : (Listof Ray) (rays-to-pixel c x y nrays)]
                         [colors : (Listof Color)
                          (map (lambda ([ray : Ray]) (shade-ray w ray)) rays)]
                         [average : Color
                          (if (= nrays 1)
                              (car colors)
                              (color/ (apply colors+ colors) (exact->inexact (length rays))))])
                    average))))
#+END_SRC

** DONE Putting It Together
:PROPERTIES:
:ACTIVATED: [2022-08-18]
:COMPLETED: [2022-08-18]
:END:

#+BEGIN_SRC racket :noweb yes :tangle apps/chapter7.rkt
#lang typed/racket
(require "../tuples.rkt")
(require "../color.rkt")
(require "../canvas.rkt")
(require "../transform.rkt")
(require "../shapes.rkt")
(require "../material.rkt")
(require "../light.rkt")
(require "../shading.rkt")
(require "../world.rkt")
(require "../camera.rkt")

(define common-material (make-material #:color (color 1. 0.9 0.9) #:specular 0.))

(define floor (sphere "floor" #:transformation (scale 10. 0.01 10.) #:material common-material))

(define left-wall
  (sphere "left-wall"
          #:transformation (transformation (scale 10. 0.01 10.)
                                           (rotate 'x (/ pi 2.))
                                           (rotate 'y (- (/ pi 4.)))
                                           (translate 0. 0. 5.))
          #:material common-material))

(define right-wall
  (sphere "right-wall"
          #:transformation (transformation (scale 10. 0.01 10.)
                                           (rotate 'x (/ pi 2.))
                                           (rotate 'y (/ pi 4.))
                                           (translate 0. 0. 5.))
          #:material common-material))

(define middle
  (sphere "middle-sphere"
          #:transformation (translate -0.5 1. 0.5)
          #:material (make-material #:color (color 0.1 1. 0.5) #:diffuse 0.7 #:specular 0.3)))

(define right
  (sphere "right-sphere"
          #:transformation (transformation (scale 0.5 0.5 0.5) (translate 1.5 0.5 -0.5))
          #:material (make-material #:color (color 0.5 1. 0.1) #:diffuse 0.7 #:specular 0.3)))

(define left
  (sphere "left-sphere"
          #:transformation (transformation (scale 0.33 0.33 0.33) (translate -1.5 0.33 -0.75))
          #:material (make-material #:color (color 1. 0.8 0.1) #:diffuse 0.7 #:specular 0.3)))

(define world
  (make-world (list floor left-wall right-wall middle right left)
              (list (point-light "white-above-left" (pt -10. 10. -10.) (color 1. 1. 1.))
                    (point-light "orange-above-right" (pt 5. 10. -10.) (color 1. 0.65 0.)))))

(define camera
  (make-camera #:hsize 500
               #:vsize 250
               #:fov (/ pi 3)
               #:transform (view-transformation (pt 0. 1.5 -5.) (pt 0. 1. 0.) (vec 0. 1. 0.))
               #:aparture-size 0.005))

(save-canvas (render world camera 6) "test.ppm")
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/scene-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../color.rkt"
         "../canvas.rkt"
         "../matrix.rkt"
         "../transform.rkt"
         "../ray.rkt"
         "../intersect.rkt"
         "../light.rkt"
         "../shading.rkt"
         "../material.rkt"
         "../shapes.rkt"
         "../world.rkt"
         "../camera.rkt")

<<check-tuple=>>

<<check-color=>>

(define scene-test
  (test-suite
   "Making a Scene"
   (test-suite
    "Building a World"
    (test-case "Creating a world"
               (define w (make-world))
               (check-equal? (hash-values (world-objects w)) '())
               (check-equal? (hash-values (world-lights w)) '()))
    ;; equal? no longer works after function struct fields are added
    ;; I'm too lazy to address this
    ;; (test-case
    ;;  "The default world"
    ;;  (define w default-world)
    ;;  (check-equal? (hash-ref (world-lights w) "default light")
    ;;                (point-light "default light" (pt -10. 10. -10.) (color 1. 1. 1.)))
    ;;  (check-equal?
    ;;   (hash-ref (world-objects w) "outer concentric sphere")
    ;;   (sphere "outer concentric sphere"
    ;;           #:material (make-material #:color (color 0.8 1.0 0.6) #:diffuse 0.7 #:specular 0.2)))
    ;;  (check-equal? (hash-ref (world-objects w) "inner concentric sphere")
    ;;                (sphere "inner concentric sphere" #:transformation (scale 0.5 0.5 0.5))))
    (test-case "Intersect a world with a ray"
               (define w default-world)
               (define r (ray (pt 0. 0. -5.) (vec 0. 0. 1.)))
               (define xs (intersect-world w r))
               (check-equal? (length xs) 4)
               (check-equal? (intersection-t (first xs)) 4.)
               (check-equal? (intersection-t (second xs)) 4.5)
               (check-equal? (intersection-t (third xs)) 5.5)
               (check-equal? (intersection-t (fourth xs)) 6.))
    (test-case "Precomputing the state of an intersection"
               (define r (ray (pt 0. 0. -5.) (vec 0. 0. 1.)))
               (define s (sphere "s"))
               (define i (intersection 4. s))
               (define comps (precomp i r))
               (check-equal? (intersection-data-t comps) (intersection-t i))
               (check-equal? (intersection-data-object comps) (intersection-obj i))
               (check-tuple= (intersection-data-point comps) (pt 0. 0. -1.))
               (check-tuple= (intersection-data-eyev comps) (vec 0. 0. -1.))
               (check-tuple= (intersection-data-normalv comps) (vec 0. 0. -1.)))
    (test-case "The hit, when an intersection occurs on the outside"
               (define r (ray (pt 0. 0. -5.) (vec 0. 0. 1.)))
               (define s (sphere "s"))
               (define i (intersection 4. s))
               (define comps (precomp i r))
               (check-equal? (intersection-data-inside comps) #f))
    (test-case "The hit, when an intersection occurs on the inside"
               (define r (ray (pt 0. 0. 0.) (vec 0. 0. 1.)))
               (define s (sphere "s"))
               (define i (intersection 1. s))
               (define comps (precomp i r))
               (check-tuple= (intersection-data-point comps) (pt 0. 0. 1.))
               (check-tuple= (intersection-data-eyev comps) (vec 0. 0. -1.))
               (check-equal? (intersection-data-inside comps) #t)
               (check-tuple= (intersection-data-normalv comps) (vec 0. 0. -1.)))
    (test-case "Shading an intersection"
               (define w default-world)
               (define r (ray (pt 0. 0. -5.) (vec 0. 0. 1.)))
               (define s (hash-ref (world-objects w) "outer concentric sphere"))
               (define i (intersection 4. s))
               (define comps (precomp i r))
               (define c (shade-intersection w comps))
               (check-color= c (color 0.38066 0.47583 0.2855)))
    (test-case
     "Shading an intersection from the inside"
     (define w0 (add-lights default-world (point-light "l" (pt 0. 0.25 0.) (color 1. 1. 1.))))
     (define w (world (world-objects default-world) (hash-remove (world-lights w0) "default light")))
     (define r (ray (pt 0. 0. 0.) (vec 0. 0. 1.)))
     (define s (hash-ref (world-objects w) "inner concentric sphere"))
     (define i (intersection 0.5 s))
     (define comps (precomp i r))
     (define c (shade-intersection w comps))
     (check-color= c (color 0.90498 0.90498 0.90498)))
    (test-case "The color when a ray misses"
               (define r (ray (pt 0. 0. -5.) (vec 0. 1. 0.)))
               (check-color= (shade-ray default-world r) black))
    (test-case "The color when a ray hits"
               (define r (ray (pt 0. 0. -5.) (vec 0. 0. 1.)))
               (check-color= (shade-ray default-world r) (color 0.38066 0.47583 0.2855)))
    (test-case
     "The color with an intersection behind the ray"
     (define w
       (let* ([w1 (make-world)]
              [w2 (add-lights w1 (point-light "default light" (pt -10. 10. -10.) (color 1. 1. 1.)))]
              [w3 (add-objects w2
                               (sphere "outer concentric sphere"
                                       #:material (make-material #:color (color 0.8 1.0 0.6)
                                                                 #:ambient 1.
                                                                 #:diffuse 0.7
                                                                 #:specular 0.2)))]
              [w4 (add-objects w3
                               (sphere "inner concentric sphere"
                                       #:transformation (scale 0.5 0.5 0.5)
                                       #:material (make-material #:ambient 1.)))])
         w4))
     (define r (ray (pt 0. 0. 0.75) (vec 0. 0. -1.)))
     (check-color= (shade-ray w r)
                   (material-color (shape-material (hash-ref (world-objects w)
                                                             "inner concentric sphere"))))))
   (test-suite "Defining a View Transformation"
               (test-case "The transformation matrix for the default orientation"
                          (define from (pt 0. 0. 0.))
                          (define to (pt 0. 0. -1.))
                          (define up (vec 0. 1. 0.))
                          (check-true (mat= (view-transformation from to up) id-mat-4)))
               (test-case "A view transformation matrix looking in positive z direction"
                          (define from (pt 0. 0. 0.))
                          (define to (pt 0. 0. 1.))
                          (define up (vec 0. 1. 0.))
                          (check-true (mat= (view-transformation from to up) (scale -1. 1. -1.))))
               (test-case "The view transformation moves the world"
                          (define from (pt 0. 0. 8.))
                          (define to (pt 0. 0. 0.))
                          (define up (vec 0. 1. 0.))
                          (check-true (mat= (view-transformation from to up) (translate 0. 0. -8.))))
               (test-case "An arbitrary view transformation"
                          (define from (pt 1. 3. 2.))
                          (define to (pt 4. -2. 8.))
                          (define up (vec 1. 1. 0.))
                          (check-true (mat= (view-transformation from to up)
                                            (mat 4
                                                 4
                                                 #[#[-0.50709 0.50709 0.67612 -2.36643]
                                                   #[0.76772 0.60609 0.12122 -2.82843]
                                                   #[-0.35857 0.59761 -0.71714 0.00000]
                                                   #[0.00000 0.00000 0.00000 1.00000]])))))
   (test-suite
    "Implementing a Camera"
    (test-case "Constructing a camera"
               (define c (make-camera #:hsize 160 #:vsize 120 #:fov (/ pi 2)))
               (check-equal? (camera-hsize c) 160)
               (check-equal? (camera-vsize c) 120)
               (check-equal? (camera-fov c) (/ pi 2))
               (check-equal? (camera-transform c) id-mat-4))
    (test-case "The pixel size for a horizontal canvas"
               (define c (make-camera #:hsize 200 #:vsize 125 #:fov (/ pi 2)))
               (check-= (camera-pixel-size c) 0.01 0.00001))
    (test-case "The pixel size for a vertical canvas"
               (define c (make-camera #:hsize 125 #:vsize 200 #:fov (/ pi 2)))
               (check-= (camera-pixel-size c) 0.01 0.00001))
    (test-case "Constructing a ray through the center of the canvas"
               (define c (make-camera #:hsize 201 #:vsize 101 #:fov (/ pi 2)))
               (define r (car (rays-to-pixel c 100 50)))
               (check-tuple= (ray-origin r) (pt 0. 0. 0.))
               (check-tuple= (ray-direction r) (vec 0. 0. -1.)))
    (test-case "Constructing a ray through a corner of the canvas"
               (define c (make-camera #:hsize 201 #:vsize 101 #:fov (/ pi 2)))
               (define r (car (rays-to-pixel c 0 0)))
               (check-tuple= (ray-origin r) (pt 0. 0. 0.))
               (check-tuple= (ray-direction r) (vec 0.66519 0.33259 -0.66851)))
    (test-case "Constructing a ray when the camera is transformed"
               (define c
                 (make-camera #:hsize 201
                              #:vsize 101
                              #:fov (/ pi 2)
                              #:transform (mat* (rotate 'y (/ pi 4)) (translate 0. -2. 5.))))
               (define r (car (rays-to-pixel c 100 50)))
               (check-tuple= (ray-origin r) (pt 0. 2. -5.))
               (check-tuple= (ray-direction r) (vec (/ (sqrt 2.) 2.) 0. (- (/ (sqrt 2.) 2.)))))
    (test-case
     "Rendering a world with a camera"
     (define c
       (make-camera #:hsize 11
                    #:vsize 11
                    #:fov (/ pi 2)
                    #:transform (view-transformation (pt 0. 0. -5.) (pt 0. 0. 0.) (vec 0. 1. 0.))))
     (define image (render default-world c))
     (check-color= (pixel-at image 5 5) (color 0.38066 0.47583 0.2855))))))

(run-tests scene-test)
#+END_SRC

* DONE Shadows
:PROPERTIES:
:ACTIVATED: [2022-08-18]
:COMPLETED: [2022-08-19]
:END:
** DONE Lighting in Shadows
:PROPERTIES:
:ACTIVATED: [2022-08-18]
:COMPLETED: [2022-08-18]
:END:
Edited the ~phong~ block under prior heading.

** DONE Testing for Shadows
:PROPERTIES:
:ACTIVATED: [2022-08-19]
:COMPLETED: [2022-08-19]
:END:

So here's the important bit for me: I decided to support multiple light sources early on, while the book is still presuming that there is only one light source at this point.

Now, my ~shade-intersection~ function already uses the total illumination from all the light sources; for an intersection, it calls ~phong~ for each light. My ~is-shadowed~ implementation needs to additionally know from which light source the point is occluded, so that it can pass that information correctly to ~phong~ in ~shade-intersection~. 

#+NAME: is-shadowed
#+BEGIN_SRC racket :noweb yes
(: is-shadowed (-> World Light Point Boolean))
(define (is-shadowed world light point)
         (let* ([v : Vector (assert (tuple- (light-position light) point) vect?)]
                [distance : Float (mag v)]
                [direction : Vector (norm v)]
                [r : Ray (ray point direction)]
                [intersections : (Listof Intersection) (intersect-world world r)]
                [hit : (U Null Intersection) (hit intersections)])
           (cond
             [(null? hit) #f]
             [(< (intersection-t hit) distance) #t]
             [else #f])))
#+END_SRC

** DONE Rendering Shadows
:PROPERTIES:
:ACTIVATED: [2022-08-19]
:COMPLETED: [2022-08-19]
:END:
Edited the ~shade-intersection~ block under prior heading.

** DONE Putting It Together
:PROPERTIES:
:ACTIVATED: [2022-08-19]
:COMPLETED: [2022-08-19]
:END:

#+BEGIN_SRC racket :noweb yes :tangle tests/shadow-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../color.rkt"
         "../canvas.rkt"
         "../matrix.rkt"
         "../transform.rkt"
         "../ray.rkt"
         "../intersect.rkt"
         "../light.rkt"
         "../shading.rkt"
         "../material.rkt"
         "../shapes.rkt"
         "../world.rkt"
         "../camera.rkt")

<<check-tuple=>>

<<check-color=>>

(define dummy (sphere "s"))

(define shadow-test
  (test-suite
   "Shadows"
   (test-suite "Lighting in Shadows"
               (test-case "Lighting with the surface in shadow"
                          (define eyev (vec 0. 0. -1.))
                          (define normalv (vec 0. 0. -1.))
                          (define light (point-light "l" (pt 0. 0. -10.) (color 1. 1. 1.)))
                          (define in-shadow #t)
                          (check-color=
                           (phong (make-material) dummy light (pt 0. 0. 0.) eyev normalv in-shadow)
                           (color 0.1 0.1 0.1))))
   (test-suite "Testing for Shadows"
               (test-case "There is no shadow when nothing is collinear with point and light"
                          (define w default-world)
                          (define p (pt 0. 10. 0.))
                          (check-false (is-shadowed w (car (hash-values (world-lights w))) p)))
               (test-case "The shadow when an object is between the point and the light"
                          (define w default-world)
                          (define p (pt 10. -10. 10.))
                          (check-true (is-shadowed w (car (hash-values (world-lights w))) p)))
               (test-case "There is no shadow when an object is behind the light"
                          (define w default-world)
                          (define p (pt -20. 20. -20.))
                          (check-false (is-shadowed w (car (hash-values (world-lights w))) p)))
               (test-case "There is no shadow when an object is behind the point"
                          (define w default-world)
                          (define p (pt -2. 2. -2.))
                          (check-false (is-shadowed w (car (hash-values (world-lights w))) p))))
   (test-suite
    "Rendering Shadows"
    (test-case "shade-hit is given an intersection in shadow"
               (define s2 (sphere "s2" #:transformation (translate 0. 0. 0.)))
               (define w
                 (make-world (list (sphere "s1") s2)
                             (list (point-light "l1" (pt 0. 0. -10.) (color 1. 1. 1.)))))
               (define r (ray (pt 0. 0. 5.) (vec 0. 0. 1.)))
               (define i (intersection 4. s2))
               (define c (shade-intersection w (precomp i r)))
               (check-color= c (color 0.1 0.1 0.1)))
    (test-case "The hit should offset the point"
               (define r (ray (pt 0. 0. -5.) (vec 0. 0. 1.)))
               (define s (sphere "s" #:transformation (translate 0. 0. 1.)))
               (define i (intersection 5. s))
               (define comps (precomp i r))
               (check-true (< (tuple-z (intersection-data-over-pt comps)) (- (/ 0.00001 2))))
               (check-true (> (tuple-z (intersection-data-point comps))
                              (tuple-z (intersection-data-over-pt comps))))))))

(run-tests shadow-test)
#+END_SRC

* DONE Planes
:PROPERTIES:
:ACTIVATED: [2022-08-21]
:COMPLETED: [2022-08-23]
:END:
** DONE Refactoring Shapes
:PROPERTIES:
:ACTIVATED: [2022-08-21]
:COMPLETED: [2022-08-21]
:END:
#+NAME: shapes-base
#+BEGIN_SRC racket :noweb yes
(struct shape
        ([id : String] [transformation : Matrix]
                       [material : Material]
                       [intersect : (-> Ray (Listof Float))]
                       [normal-at : (-> Point Vector)])
  #:prefab
  #:type-name Shape)
#+END_SRC

#+NAME: sphere
#+BEGIN_SRC racket :noweb yes
(struct _sphere shape () #:prefab #:type-name Sphere)

(: sphere (->* (String) (#:transformation Matrix #:material Material) Shape))
(define (sphere id #:transformation [transformation id-mat-4] #:material [material (make-material)])
  (: sphere-intersect (-> Ray (Listof Float)))
  (define (sphere-intersect ray)
    (let* ([center-to-ray : Vector (assert (tuple- (ray-origin ray) (pt 0. 0. 0.)) vect?)]
           [a : Float (dot* (ray-direction ray) (ray-direction ray))]
           [b : Float (* 2 (dot* (ray-direction ray) center-to-ray))]
           [c : Float (- (dot* center-to-ray center-to-ray) 1)]
           [discriminant : Float (- (sqr b) (* 4. a c))]
           [solution : (-> (U '+ '-) Float)
                     (lambda (sign)
                       (cast
                        (/ ((if (eq? sign '-) - +) (- b) (sqrt discriminant)) (* 2 a))
                        Float))])
      (if (< discriminant 0.)
          '()
          (list (solution '-) (solution '+)))))
  (: sphere-normal-at (-> Point Vector))
  (define (sphere-normal-at point)
    (assert (tuple- point (pt 0. 0. 0.)) vect?))
  (_sphere id transformation material sphere-intersect sphere-normal-at))
#+END_SRC

#+NAME: set-transformation
#+BEGIN_SRC racket :noweb yes
(: set-transformation
   (-> (->* (String) (#:transformation Matrix #:material Material) Shape) Shape Matrix Shape))
(define (set-transformation constructor val trans)
  (constructor (shape-id val) #:transformation trans #:material (shape-material val)))
#+END_SRC

#+NAME: set-material
#+BEGIN_SRC racket :noweb yes
(: set-material
   (-> (->* (String) (#:transformation Matrix #:material Material) Shape) Shape Material Shape))
(define (set-material constructor val material)
  (constructor (shape-id val) #:transformation (shape-transformation val) #:material material))
#+END_SRC

#+NAME: intersect
#+BEGIN_SRC racket :noweb yes
(: intersect (-> Shape Ray (Listof Intersection)))
(define (intersect shape ray)
  (let ([local-ray : Ray
         (transform-ray ray (inverse (shape-transformation shape)))])
    (map (lambda ([t : Float]) (intersection t shape)) ((shape-intersect shape) local-ray))))
#+END_SRC

#+NAME: normal-at
#+BEGIN_SRC racket :noweb yes
(: normal-at (-> Shape Point Vector))
(define (normal-at obj world-point)
  (let* ([trans : Matrix (shape-transformation obj)]
         [obj-pt : Point (assert (mat-t* (inverse trans) world-point) point?)]
         [obj-norm : Vector ((shape-normal-at obj) obj-pt)]
         [world-norm : Tuple (mat-t* (transpose (inverse trans)) obj-norm)])
    (norm (vec (tuple-x world-norm) (tuple-y world-norm) (tuple-z world-norm)))))
#+END_SRC

** DONE Implementing a Plane
:PROPERTIES:
:ACTIVATED: [2022-08-23]
:COMPLETED: [2022-08-23]
:END:
#+NAME: plane
#+BEGIN_SRC racket :noweb yes
(struct _plane shape () #:prefab #:type-name Plane)

(: plane (->* (String) (#:transformation Matrix #:material Material) Shape))
(define (plane id #:transformation [transformation id-mat-4] #:material [material (make-material)])
  (: plane-intersect (-> Ray (Listof Float)))
  (define (plane-intersect ray)
    (if (< (abs (tuple-y (ray-direction ray))) EPSILON)
        '()
        (list (/ (- (tuple-y (ray-origin ray))) (tuple-y (ray-direction ray))))))
  (: plane-normal-at (-> Point Vector))
  (define (plane-normal-at point)
    (vec 0. 1. 0.))
  (_plane id transformation material plane-intersect plane-normal-at))
#+END_SRC

** DONE Putting It Together
:PROPERTIES:
:ACTIVATED: [2022-08-23]
:COMPLETED: [2022-08-23]
:END:

#+BEGIN_SRC racket :noweb yes :tangle tests/planes-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../color.rkt"
         "../canvas.rkt"
         "../matrix.rkt"
         "../transform.rkt"
         "../ray.rkt"
         "../intersect.rkt"
         "../light.rkt"
         "../shading.rkt"
         "../material.rkt"
         "../shapes.rkt"
         "../world.rkt"
         "../camera.rkt")

<<check-tuple=>>

<<check-color=>>

(define planes-test
  (test-suite "Planes"
              (test-case "The normal of a plane is constant everywhere"
                         (define p (plane "p"))
                         (check-tuple= ((shape-normal-at p) (pt 0. 0. 0.)) (vec 0. 1. 0.))
                         (check-tuple= ((shape-normal-at p) (pt 10. 0. -10.)) (vec 0. 1. 0.))
                         (check-tuple= ((shape-normal-at p) (pt -5. 0. 150.)) (vec 0. 1. 0.)))
              (test-case "Intersect with a ray parallel to the plane"
                         (define p (plane "p"))
                         (define r (ray (pt 0. 10. 0.) (vec 0. 0. 1.)))
                         (check-equal? ((shape-intersect p) r) '()))
              (test-case "Intersect with a coplanar ray"
                         (define p (plane "p"))
                         (define r (ray (pt 0. 0. 0.) (vec 0. 0. 1.)))
                         (check-equal? ((shape-intersect p) r) '()))
              (test-case "A ray intersecting a plane from above"
                         (define p (plane "p"))
                         (define r (ray (pt 0. 1. 0.) (vec 0. -1. 0.)))
                         (check-equal? ((shape-intersect p) r) '(1.)))
              (test-case "A ray intersecting a plane from below"
                         (define p (plane "p"))
                         (define r (ray (pt 0. -1. 0.) (vec 0. 1. 0.)))
                         (check-equal? ((shape-intersect p) r) '(1.)))))

(run-tests planes-test)
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle apps/chapter9.rkt
#lang typed/racket
(require "../tuples.rkt")
(require "../color.rkt")
(require "../canvas.rkt")
(require "../transform.rkt")
(require "../shapes.rkt")
(require "../material.rkt")
(require "../light.rkt")
(require "../shading.rkt")
(require "../world.rkt")
(require "../camera.rkt")

(define common-material (make-material #:color (color 1. 0.9 0.9) #:specular 0.))

(define floor (plane "floor" #:material common-material))

(define middle
  (sphere "middle-sphere"
          #:transformation (translate -0.5 1. 0.5)
          #:material (make-material #:color (color 0.1 1. 0.5) #:diffuse 0.7 #:specular 0.3)))

(define right
  (sphere "right-sphere"
          #:transformation (transformation (scale 0.5 0.5 0.5) (translate 1.5 0.5 -0.5))
          #:material (make-material #:color (color 0.5 1. 0.1) #:diffuse 0.7 #:specular 0.3)))

(define left
  (sphere "left-sphere"
          #:transformation (transformation (scale 0.33 0.33 0.33) (translate -1.5 0.33 -0.75))
          #:material (make-material #:color (color 1. 0.8 0.1) #:diffuse 0.7 #:specular 0.3)))

(define world
  (make-world (list floor middle right left)
              (list (point-light "white-above-left" (pt -10. 10. -10.) (color 1. 1. 1.))
                    (point-light "sky-blue-above-right" (pt 5. 10. -10.) (color 0.53 0.81 0.92)))))

(define camera
  (make-camera #:hsize 1080
               #:vsize 720
               #:fov (/ pi 3)
               #:transform (view-transformation (pt 0. 1.5 -5.) (pt 0. 1. 0.) (vec 0. 1. 0.))
               #:aparture-size 0.001))

(save-canvas (render world camera 5) "test.ppm")
#+END_SRC

* DONE Patterns
:PROPERTIES:
:ACTIVATED: [2022-08-23]
:COMPLETED: [2022-08-31]
:END:
** DONE Making a Striped Pattern
:PROPERTIES:
:ACTIVATED: [2022-08-23]
:COMPLETED: [2022-08-26]
:END:
#+NAME: pattern-base
#+BEGIN_SRC racket :noweb yes
(struct _pattern ([color-at : (-> Point Color)] [transformation : Matrix])
  #:prefab
  #:type-name Pattern)

(: pattern
   (->* ((U 'stripe 'gradient 'ring 'checker 'plain) (Listof Color))
        (#:transformation Matrix) Pattern))
(define (pattern type
          colors
          #:transformation [transformation id-mat-4])
  (cond
    [(eq? type 'stripe) (stripe (cast colors (List Color Color)) transformation)]
    [(eq? type 'gradient) (gradient (cast colors (List Color Color)) transformation)]
    [(eq? type 'ring) (ring (cast colors (List Color Color)) transformation)]
    [(eq? type 'checker) (checker (cast colors (List Color Color)) transformation)]
    [(eq? type 'plain) (_pattern (lambda (point) (car colors)) id-mat-4)]
    [else (error "Illegal operation: no pattern type: " type)]))

(define pattern-color-at _pattern-color-at)

(define pattern-transformation _pattern-transformation)
#+END_SRC

#+NAME: pattern-at
#+BEGIN_SRC racket :noweb yes
(: pattern-at (-> Pattern Shape Point Color))
(define (pattern-at pattern object point)
  (let* ([obj-pt (mat-t* (inverse (shape-transformation object)) point)]
         [pattern-pt (assert (mat-t* (inverse (pattern-transformation pattern)) obj-pt) point?)])
    ((_pattern-color-at pattern) pattern-pt)))
#+END_SRC

#+NAME: stripe
#+BEGIN_SRC racket :noweb yes
(: stripe (-> (List Color Color) Matrix Pattern))
(define (stripe colors transformation)
  (_pattern (lambda (point)
              (if (= 0 (remainder (exact-floor (tuple-x point)) 2)) (first colors) (second colors))) transformation))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
(struct material
        ([color : Color] [ambient : Float] [diffuse : Float] [specular : Float] [shininess : Float] [pattern : Pattern])
  #:prefab
  #:type-name Material)

(:
 make-material
 (->* () (#:color Color #:ambient Float #:diffuse Float #:specular Float #:shininess Float #:pattern Pattern) Material))
(define (make-material #:color [color (color 1. 1. 1.)]
                          #:ambient [ambient 0.1]
                          #:diffuse [diffuse 0.9]
                          #:specular [specular 0.9]
                          #:shininess [shininess 200.]
                          #:pattern [pattern (pattern 'plain (list color))])
  (material color ambient diffuse specular shininess pattern))
#+END_SRC

#+NAME: phong
#+BEGIN_SRC racket :noweb yes
(: phong (->* (Material Shape Light Point Vector Vector) (Boolean) Color))
(define (phong material object light point eyev normalv [in-shadow #f])
  (let* ([pattern : Pattern (material-pattern material)]
         [pattern-color : Color
                        (pattern-at pattern object point)]
         [blended : Color
          (color* pattern-color (light-intensity light))]
         [ambient : Color
          (color* blended (material-ambient material))]
         [lightv : Vector
          (norm (assert (tuple- (light-position light) point) vect?))]
         [*light-normal : Float (dot* lightv normalv)]
         [diffuse : Color
          (if (< *light-normal 0.)
              black
              (color* blended (* (material-diffuse material) *light-normal)))]
         [specular : Color
          (if (< *light-normal 0.)
              black
              (let* ([reflectv : Vector
                      (reflect (assert (-tuple lightv) vect?) normalv)]
                     [*reflect-eye : Float (dot* reflectv eyev)])
                (if (< *reflect-eye 0.)
                    black
                    (color* (light-intensity light)
                            (* (material-specular material)
                               (cast (expt *reflect-eye (material-shininess material)) Float))))))])
    (if in-shadow
        ambient
        (colors+ ambient diffuse specular))))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
(: shade-intersection (-> World IntersectionData Color))
(define (shade-intersection world comps)
  (let ([per-light-shading
         :
         (Listof Color)
         (for/list ([light : Light (in-hash-values (world-lights world))])
           (phong (shape-material (intersection-data-object comps))
                  (intersection-data-object comps)
                  light
                  (intersection-data-over-pt comps)
                  (intersection-data-eyev comps)
                  (intersection-data-normalv comps)
                  (is-shadowed world light (intersection-data-over-pt comps))))])
    (apply colors+ per-light-shading)))
#+END_SRC

** DONE Transforming Patterns
:PROPERTIES:
:ACTIVATED: [2022-08-27]
:COMPLETED: [2022-08-27]
:END:
** DONE Generalizing Patterns
:PROPERTIES:
:ACTIVATED: [2022-08-27]
:COMPLETED: [2022-08-27]
:END:
** DONE Making a Gradient Pattern
:PROPERTIES:
:ACTIVATED: [2022-08-28]
:COMPLETED: [2022-08-28]
:END:
#+NAME: gradient
#+BEGIN_SRC racket :noweb yes
(: gradient (-> (List Color Color) Matrix Pattern))
(define (gradient colors transformation)
  (_pattern (lambda (point)
              (let ([delta : Color
                     (color- (second colors) (first colors))]
                    [frac : Float
                          (- (tuple-x point) (floor (tuple-x point)))])
                (color+ (first colors) (color* delta frac))))
            transformation))
#+END_SRC

** DONE Making a Ring Pattern
:PROPERTIES:
:ACTIVATED: [2022-08-28]
:COMPLETED: [2022-08-29]
:END:
#+NAME: ring
#+BEGIN_SRC racket :noweb yes
(: ring (-> (List Color Color) Matrix Pattern))
(define (ring colors transformation)
  (_pattern
   (lambda (point)
     (if (= 0 (remainder (exact-floor (sqrt (+ (sqr (tuple-x point)) (sqr (tuple-z point))))) 2))
         (first colors)
         (second colors)))
   transformation))
#+END_SRC

** DONE Making a 3D Checker Pattern
:PROPERTIES:
:ACTIVATED: [2022-08-29]
:COMPLETED: [2022-08-29]
:END:
#+NAME: checker
#+BEGIN_SRC racket :noweb yes
(: checker (-> (List Color Color) Matrix Pattern))
(define (checker colors transformation)
  (_pattern (lambda (point)
              (if (= 0
                     (remainder (+ (exact-floor (tuple-x point))
                                   (exact-floor (tuple-y point))
                                   (exact-floor (tuple-z point)))
                                2))
                  (first colors)
                  (second colors)))
            transformation))
#+END_SRC

** DONE Putting It Together
:PROPERTIES:
:ACTIVATED: [2022-08-29]
:COMPLETED: [2022-08-31]
:END:

#+BEGIN_SRC racket :noweb yes :tangle tests/patterns-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../color.rkt"
         "../canvas.rkt"
         "../matrix.rkt"
         "../transform.rkt"
         "../ray.rkt"
         "../intersect.rkt"
         "../light.rkt"
         "../shading.rkt"
         "../material.rkt"
         "../shapes.rkt"
         "../world.rkt"
         "../camera.rkt"
         "../patterns.rkt")

<<check-tuple=>>

<<check-color=>>

(define dummy (sphere "s"))

(: test-pattern (->* () (Matrix) Pattern))
(define (test-pattern [transformation id-mat-4])
  (_pattern (lambda (point) (color (tuple-x point) (tuple-y point) (tuple-z point))) transformation))

(define patterns-test
  (test-suite
   "Patterns"
   (test-suite "Making a Striped Pattern"
               (test-case "A stripe pattern is constant in y"
                          (define p
                            (pattern 'stripe
                              (list white black)))
                          (check-equal? (pattern-at p dummy (pt 0. 0. 0.)) white)
                          (check-equal? (pattern-at p dummy (pt 0. 1. 0.)) white)
                          (check-equal? (pattern-at p dummy (pt 0. 2. 0.)) white))
               (test-case "A stripe pattern is constant in z"
                          (define p
                            (pattern 'stripe
                              (list white black)))
                          (check-equal? (pattern-at p dummy (pt 0. 0. 0.)) white)
                          (check-equal? (pattern-at p dummy (pt 0. 0. 1.)) white)
                          (check-equal? (pattern-at p dummy (pt 0. 0. 2.)) white))
               (test-case "A stripe pattern alternates in x"
                          (define p
                            (pattern 'stripe
                              (list white black)))
                          (check-equal? (pattern-at p dummy (pt 0. 0. 0.)) white)
                          (check-equal? (pattern-at p dummy (pt 0.9 0. 0.)) white)
                          (check-equal? (pattern-at p dummy (pt 1. 0. 0.)) black)
                          (check-equal? (pattern-at p dummy (pt -0.1 0. 0.)) black)
                          (check-equal? (pattern-at p dummy (pt -1. 0. 0.)) black)
                          (check-equal? (pattern-at p dummy (pt -1.1 0. 0.)) white))
               (test-case "Lighting with a pattern applied"
                          (define m
                            (make-material #:ambient 1.
                                           #:diffuse 0.
                                           #:specular 0.
                                           #:pattern (pattern 'stripe
                                                       (list white black))))
                          (define eyev (vec 0. 0. -1.))
                          (define normalv (vec 0. 0. -1.))
                          (define light (point-light "l" (pt 0. 0. -10.) white))
                          (check-color= (phong m dummy light (pt 0.9 0. 0.) eyev normalv #f) white)
                          (check-color= (phong m dummy light (pt 1.1 0. 0.) eyev normalv #f) black)))
   (test-suite "Transforming Patterns"
               (test-case "Stripes with an object transformation"
                          (define s (sphere "s" #:transformation (scale 2. 2. 2.)))
                          (define p
                            (pattern 'stripe
                              (list white black)))
                          (check-color= (pattern-at p s (pt 1.5 0. 0.)) white))
               (test-case "Stripes with a pattern transformation"
                          (define s (sphere "s"))
                          (define p
                            (pattern 'stripe
                              (list white black)
                              #:transformation (scale 2. 2. 2.)))
                          (check-color= (pattern-at p s (pt 1.5 0. 0.)) white))
               (test-case "Stripes with both an object and a pattern transformation"
                          (define s (sphere "s" #:transformation (scale 2. 2. 2.)))
                          (define p
                            (pattern 'stripe
                              (list white black)
                              #:transformation (translate 0.5 0. 0.)))
                          (check-color= (pattern-at p s (pt 2.5 0. 0.)) white)))
   (test-suite "Generalizing Patterns"
               (test-case "A pattern with an object transformation"
                          (define s (sphere "s" #:transformation (scale 2. 2. 2.)))
                          (define t (test-pattern))
                          (check-color= (pattern-at t s (pt 2. 3. 4.)) (color 1. 1.5 2.)))
               (test-case "A pattern with a pattern transformation"
                          (define s (sphere "s"))
                          (define t (test-pattern (scale 2. 2. 2.)))
                          (check-color= (pattern-at t s (pt 2. 3. 4.)) (color 1. 1.5 2.)))
               (test-case "A pattern with both an object and a pattern transformation"
                          (define s (sphere "s" #:transformation (scale 2. 2. 2.)))
                          (define t (test-pattern (translate 0.5 1. 1.5)))
                          (check-color= (pattern-at t s (pt 2.5 3. 3.5)) (color 0.75 0.5 0.25))))
   (test-suite "Making a Gradient Pattern"
               (test-case "A gradient linearly interpolates between colors"
                          (define p
                            (pattern 'gradient
                              (list white black)))
                          (check-color= (pattern-at p dummy (pt 0. 0. 0.)) white)
                          (check-color= (pattern-at p dummy (pt 0.25 0. 0.)) (color 0.75 0.75 0.75))
                          (check-color= (pattern-at p dummy (pt 0.5 0. 0.)) (color 0.5 0.5 0.5))
                          (check-color= (pattern-at p dummy (pt 0.75 0. 0.)) (color 0.25 0.25 0.25))))
   (test-suite "Making a Ring Pattern"
               (test-case "A ring should extend in both x and z"
                          (define p
                            (pattern 'ring
                              (list white black)))
                          (check-color= (pattern-at p dummy (pt 0. 0. 0.)) white)
                          (check-color= (pattern-at p dummy (pt 1. 0. 0.)) black)
                          (check-color= (pattern-at p dummy (pt 0. 0. 1.)) black)
                          (check-color= (pattern-at p dummy (pt 0.708 0. 0.708)) black)))
   (test-suite "Making a 3D Checker Pattern"
               (let ([p (pattern 'checker
                          (list white black))])
                 (test-case "Checkers should repeat in x"
                            (check-color= (pattern-at p dummy (pt 0. 0. 0.)) white)
                            (check-color= (pattern-at p dummy (pt 0.99 0. 0.)) white)
                            (check-color= (pattern-at p dummy (pt 1.01 0. 0.)) black))
                 (test-case "Checkers should repeat in y"
                            (check-color= (pattern-at p dummy (pt 0. 0. 0.)) white)
                            (check-color= (pattern-at p dummy (pt 0. 0.99 0.)) white)
                            (check-color= (pattern-at p dummy (pt 0. 1.01 0.)) black))
                 (test-case "Checkers should repeat in z"
                            (check-color= (pattern-at p dummy (pt 0. 0. 0.)) white)
                            (check-color= (pattern-at p dummy (pt 0. 0. 0.99)) white)
                            (check-color= (pattern-at p dummy (pt 0. 0. 1.01)) black))))))

(run-tests patterns-test)
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle apps/chapter10.rkt
#lang typed/racket
(require "../tuples.rkt")
(require "../color.rkt")
(require "../canvas.rkt")
(require "../transform.rkt")
(require "../shapes.rkt")
(require "../material.rkt")
(require "../patterns.rkt")
(require "../light.rkt")
(require "../shading.rkt")
(require "../world.rkt")
(require "../camera.rkt")


(define common-material
  (make-material #:color (color 1. 0.9 0.9)
                 #:specular 0.
                 #:reflective 0.5
                 #:pattern (pattern 'checker
                             (list white black)
                             #:transformation (rotate 'y (/ pi 4)))))

(define floor (plane "floor" #:material common-material))

(define middle
  (sphere "middle-sphere"
          #:transformation (translate -0.5 1. 0.5)
          #:material (make-material #:color (color 0.1 1. 0.5)
                                    #:diffuse 0.7
                                    #:specular 0.3
                                    #:reflective 0.7
                                    #:pattern (pattern 'gradient
                                                (list (color 0.1 0. 0.6) (color 1. 0. 0.1))
                                                #:transformation (scale 0.5 0.5 0.5)))))

(define right
  (sphere "right-sphere"
          #:transformation (transformation (scale 0.5 0.5 0.5) (translate 1.5 0.5 -0.5))
          #:material (make-material #:color (color 0.5 1. 0.1)
                                    #:diffuse 0.7
                                    #:specular 0.3
                                    #:reflective 0.6
                                    #:pattern (pattern 'stripe
                                                (list (color 0.4 0.8 0.1) (color 0. 0.4 0.8))
                                                #:transformation (scale 0.2 0.2 0.2)))))

(define left
  (sphere "left-sphere"
          #:transformation (transformation (scale 0.33 0.33 0.33) (translate -1.5 0.33 -0.75))
          #:material (make-material #:color (color 1. 0.8 0.1)
                                    #:diffuse 0.7
                                    #:specular 0.3
                                    #:reflective 0.3
                                    #:pattern (pattern 'ring
                                                (list (color 1. 0.6 0.2) (color 0.4 0.9 0.))
                                                #:transformation (scale 0.2 0.2 0.2)))))

(define world
  (make-world (list floor middle right left)
              (list (point-light "white-above-left" (pt -10. 10. -10.) (color 0.8 0.8 0.8))
                    (point-light "white-above-right" (pt 5. 10. -10.) (color 0.8 0.8 0.8)))))

(define camera
  (make-camera #:hsize 1080
               #:vsize 720
               #:fov (/ pi 3)
               #:transform (view-transformation (pt 0. 1.5 -5.) (pt 0. 1. 0.) (vec 0. 1. 0.))
               #:aparture-size 0.001))

(save-canvas (render world camera 4 10) "test.ppm")
#+END_SRC

* NEXT Reflection and Refraction
:PROPERTIES:
:ACTIVATED: [2022-09-01]
:END:
** DONE Reflection
:PROPERTIES:
:ACTIVATED: [2022-09-01]
:COMPLETED: [2022-09-01]
:END:
#+NAME: material
#+BEGIN_SRC racket :noweb yes
(struct material
        ([color : Color] [ambient : Float] [diffuse : Float] [specular : Float] [shininess : Float] [reflective : Float] [pattern : Pattern])
  #:prefab
  #:type-name Material)

(:
 make-material
 (->* () (#:color Color #:ambient Float #:diffuse Float #:specular Float #:shininess Float #:reflective Float #:pattern Pattern) Material))
(define (make-material #:color [color (color 1. 1. 1.)]
                          #:ambient [ambient 0.1]
                          #:diffuse [diffuse 0.9]
                          #:specular [specular 0.9]
                          #:shininess [shininess 200.]
                          #:reflective [reflective 0.]
                          #:pattern [pattern (pattern 'plain (list color))])
  (material color ambient diffuse specular shininess reflective pattern))
#+END_SRC

#+NAME: precomp
#+BEGIN_SRC racket :noweb yes
(struct intersection-data
        ([t : Float] [object : Shape]
                     [point : Point]
                     [eyev : Vector]
                     [normalv : Vector]
                     [reflectv : Vector]
                     [inside : Boolean]
                     [over-pt : Point])
  #:prefab
  #:type-name IntersectionData)

(: precomp (-> Intersection Ray IntersectionData))
(define (precomp intersection ray)
  (let* ([t (intersection-t intersection)]
         [object (intersection-obj intersection)]
         [point (pos ray t)]
         [eyev (assert (-tuple (ray-direction ray)) vect?)]
         [normalv (normal-at object point)]
         [-normalv (assert (-tuple normalv) vect?)]
         [inside (if (< (dot* normalv eyev) 0.) #t #f)]
         [adjusted-normalv (if inside -normalv normalv)]
         [reflectv (reflect (ray-direction ray) adjusted-normalv)]
         [over-pt (assert (tuple+ point (tuple* adjusted-normalv EPSILON)) point?)])
    (intersection-data t object point eyev adjusted-normalv reflectv inside over-pt)))
#+END_SRC

#+NAME: shade-reflection
#+BEGIN_SRC racket :noweb yes
(: shade-reflection (-> World IntersectionData Exact-Nonnegative-Integer Color))
(define (shade-reflection world comps remaining)
  (let ([reflective (material-reflective (shape-material (intersection-data-object comps)))])
    (if (or (= 0 reflective) (< remaining 1))
        black
        (let* ([reflect-ray (ray (intersection-data-over-pt comps)
                                 (intersection-data-reflectv comps))]
               [reflect-color (shade-ray world reflect-ray (sub1 remaining))])
          (color* reflect-color reflective)))))
#+END_SRC

#+NAME: shade-intersection
#+BEGIN_SRC racket :noweb yes
(: shade-intersection (->* (World IntersectionData) (Exact-Nonnegative-Integer) Color))
(define (shade-intersection world comps [remaining 5])
  (let ([per-light-shading
         :
         (Listof Color)
         (for/list ([light : Light (in-hash-values (world-lights world))])
           (colors+ (phong (shape-material (intersection-data-object comps))
                           (intersection-data-object comps)
                           light
                           (intersection-data-over-pt comps)
                           (intersection-data-eyev comps)
                           (intersection-data-normalv comps)
                           (is-shadowed world light (intersection-data-over-pt comps)))
                    (shade-reflection world comps remaining)))])
    (apply colors+ per-light-shading)))
#+END_SRC

#+NAME: shade-ray
#+BEGIN_SRC racket :noweb yes
(: shade-ray (->* (World Ray) (Exact-Nonnegative-Integer) Color))
(define (shade-ray world ray [remaining 5])
  (let* ([intersections : (Listof Intersection) (intersect-world world ray)]
         ;; sorted intersections
         [hit : (U Intersection Null) (fast-hit intersections)])
    (if (null? hit)
        black
        (let* ([precomp : IntersectionData (precomp hit ray)]
               [shade : Color (shade-intersection world precomp remaining)])
          shade))))
#+END_SRC

** TODO Transparency and Refraction
** TODO Fresnel Effect
** TODO Putting It Together

#+BEGIN_SRC racket :noweb yes :tangle tests/reflection-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../color.rkt"
         "../canvas.rkt"
         "../matrix.rkt"
         "../transform.rkt"
         "../ray.rkt"
         "../intersect.rkt"
         "../light.rkt"
         "../shading.rkt"
         "../material.rkt"
         "../shapes.rkt"
         "../world.rkt"
         "../camera.rkt"
         "../patterns.rkt")

<<check-tuple=>>

<<check-color=>>

(define reflection-test
  (test-suite
   "Reflection"
   (test-case "Precomputing the reflection vector"
              (define s (plane "p"))
              (define r (ray (pt 0. 1. -1.) (vec 0. (- (/ (sqrt 2.) 2.)) (/ (sqrt 2.) 2.))))
              (define i (intersection (sqrt 2.) s))
              (define comps (precomp i r))
              (check-tuple= (intersection-data-reflectv comps)
                            (vec 0. (/ (sqrt 2.) 2.) (/ (sqrt 2.) 2.))))
   (test-case
    "The reflected color for a nonreflective material"
    (define w
      (make-world (list (sphere "outer concentric sphere"
                                #:material (make-material #:color (color 0.8 1.0 0.6)
                                                          #:ambient 1.
                                                          #:diffuse 0.7
                                                          #:specular 0.2))
                        (sphere "inner concentric sphere" #:transformation (scale 0.5 0.5 0.5)))
                  (list (point-light "default light" (pt -10. 10. -10.) (color 1. 1. 1.)))))
    (define r (ray (pt 0. 0. 0.) (vec 0. 0. 1.)))
    (define i (intersection 1. (hash-ref (world-objects w) "outer concentric sphere")))
    (define comps (precomp i r))
    (check-color= (shade-reflection w comps 1) black))
   (test-case
    "The reflected color for a reflective material"
    (define s
      (plane "p" #:material (make-material #:reflective 0.5) #:transformation (translate 0. -1. 0.)))
    (define w (add-objects default-world s))
    (define r (ray (pt 0. 0. -3.) (vec 0. (- (/ (sqrt 2.) 2.)) (/ (sqrt 2.) 2.))))
    (define i (intersection (sqrt 2.) s))
    (define comps (precomp i r))
    (check-color= (shade-reflection w comps 1) (color 0.19033 0.23792 0.14275)))
   (test-case
    "shade-intersection with a reflective material"
    (define s
      (plane "p" #:material (make-material #:reflective 0.5) #:transformation (translate 0. -1. 0.)))
    (define w (add-objects default-world s))
    (define r (ray (pt 0. 0. -3.) (vec 0. (- (/ (sqrt 2.) 2.)) (/ (sqrt 2.) 2.))))
    (define i (intersection (sqrt 2.) s))
    (define comps (precomp i r))
    (check-color= (shade-intersection w comps) (color 0.87676 0.92434 0.82917)))
   (test-case "shade-ray with mutually reflective surfaces"
              (define w
                (make-world (list (plane "lower"
                                         #:material (make-material #:reflective 1.)
                                         #:transformation (translate 0. -1. 0.))
                                  (plane "upper"
                                         #:material (make-material #:reflective 1.)
                                         #:transformation (translate 0. 1. 0.)))
                            (list (point-light "l" (pt 0. 0. 0.) white))))
              (define r (ray (pt 0. 0. 0.) (vec 0. 1. 0.)))
              (check-color= (shade-ray w r) (color 11.4 11.4 11.4)))
   (test-case
    "The reflected color at the maximum recursive depth"
    (define s
      (plane "p" #:material (make-material #:reflective 0.5) #:transformation (translate 0. -1. 0.)))
    (define w (add-objects default-world s))
    (define r (ray (pt 0. 0. -3.) (vec 0. (- (/ (sqrt 2.) 2.)) (/ (sqrt 2.) 2.))))
    (define i (intersection (sqrt 2.) s))
    (define comps (precomp i r))
    (check-color= (shade-reflection w comps 0) black))))

(run-tests reflection-test)
#+END_SRC

* Cubes
** Intersecting a Ray with a Cube
** Finding the Normal on a Cube
** Putting It Together
* Cylinders
** Intersecting a Ray with a Cylinder
** Finding the Normal on a Cylinder
** Truncating Cylinders
** Capped Cylinders
** Cones
** Putting It Together
* Groups
** Implementing Groups
** Finding the Normal on a Child Object
** Using Bounding Boxes to Optimize Large Scenes
** Putting It Together
* Triangles
** Triangles
** Wavefront OBJ Files
** Smooth Triangles
** Smooth Triangles in OBJ Files
** Putting It Together
* Constructive Solid Geometry (CSG)
** Implementing CSG
** Coloring CSG Shapes
** Putting It Together
* Next Steps
** Area Lights and Soft Shadows
** Spotlights
** Focal Blur
** Motion Blur
** Anti-aliasing
** Texture Maps
** Normal Perturbation
** Torus Primitive
** Wrapping It Up
* Rendering the Cover Image
* Tangled source blocks
** Tuples
#+BEGIN_SRC racket :noweb yes :tangle tuples.rkt
#lang typed/racket
(provide (all-defined-out))

(define EPSILON 0.00001)

<<tuple-base>>

<<f=>>

<<tuple+>>

<<tuples+>>

<<tuple->>

<<tuples->>

<<-tuple>>

<<tuple*>>

<<tuple/>>

<<mag>>

<<norm>>

<<dot*>>

<<cross*>>

<<reflect>>
#+END_SRC

** Color
#+BEGIN_SRC racket :noweb yes :tangle color.rkt
#lang typed/racket
(provide (except-out (all-defined-out) color-op scalar-helper))

<<color-base>>

<<color-ops>>

<<colors>>
#+END_SRC

** Canvas
#+BEGIN_SRC racket :noweb yes :tangle canvas.rkt
#lang typed/racket
(provide (all-defined-out))
(require "color.rkt")

<<canvas-immutable>>
#+END_SRC

** Matrix
#+BEGIN_SRC racket :noweb yes :tangle matrix.rkt
#lang typed/racket
(provide (except-out (all-defined-out) det-2))
(require "tuples.rkt")

<<matrix-base>>

<<build-matrix>>

<<mat*>>

<<mat-t*>>

<<id-mat>>

<<id-mat-4>>

<<transpose>>

<<submat>>

<<det>>

<<cofactor>>

<<inverse>>
#+END_SRC

** Transform
#+BEGIN_SRC racket :noweb yes :tangle transform.rkt
#lang typed/racket
(provide (all-defined-out))
(require "tuples.rkt")
(require "matrix.rkt")

<<translate>>

<<scale>>

<<rotate>>

<<shear>>

<<transform>>

<<view-transformation>>
#+END_SRC

** Ray
#+BEGIN_SRC racket :noweb yes :tangle ray.rkt
#lang typed/racket
(provide (all-defined-out))
(require "tuples.rkt")
(require "matrix.rkt")
(require "transform.rkt")

<<ray-base>>

<<transform-ray>>
#+END_SRC

** Material
#+BEGIN_SRC racket :noweb yes :tangle material.rkt
#lang typed/racket
(provide (all-defined-out))
(require "color.rkt")
(require "matrix.rkt")
(require "patterns.rkt")

<<material>>
#+END_SRC

** World
#+BEGIN_SRC racket :noweb yes :tangle world.rkt
#lang typed/racket
(provide (all-defined-out))
(require "tuples.rkt")
(require "color.rkt")
(require "transform.rkt")
(require "material.rkt")
(require "shapes.rkt")
(require "light.rkt")

<<world-base>>
#+END_SRC

** Intersect
#+BEGIN_SRC racket :noweb yes :tangle intersect.rkt
#lang typed/racket
(provide (all-defined-out))
(require "matrix.rkt")
(require "ray.rkt")
(require "shapes.rkt")
(require "world.rkt")

<<intersection>>

<<intersect>>

<<hit>>

<<intersect-world>>
#+END_SRC

** Camera
#+BEGIN_SRC racket :noweb yes :tangle camera.rkt
#lang typed/racket
(provide (all-defined-out))
(require "tuples.rkt")
(require "matrix.rkt")
(require "color.rkt")
(require "canvas.rkt")
(require "ray.rkt")
(require "shading.rkt")
(require "world.rkt")

(define randgen (current-pseudo-random-generator))

<<camera-base>>

<<rays-to-pixel>>

<<render>>
#+END_SRC

** Light
#+BEGIN_SRC racket :noweb yes :tangle light.rkt
#lang typed/racket
(provide (all-defined-out))
(require "tuples.rkt")
(require "color.rkt")

<<light>>
#+END_SRC

** Shading
#+BEGIN_SRC racket :noweb yes :tangle shading.rkt
#lang typed/racket
(provide (all-defined-out))
(require "tuples.rkt")
(require "color.rkt")
(require "ray.rkt")
(require "intersect.rkt")
(require "material.rkt")
(require "patterns.rkt")
(require "shapes.rkt")
(require "light.rkt")
(require "world.rkt")

<<phong>>

<<is-shadowed>>

<<precomp>>

<<shade-intersection>>

<<shade-ray>>

<<shade-reflection>>
#+END_SRC

** Shapes
#+BEGIN_SRC racket :noweb yes :tangle shapes.rkt
#lang typed/racket
(provide (all-defined-out))
(require "tuples.rkt")
(require "matrix.rkt")
(require "material.rkt")
(require "ray.rkt")
(require "color.rkt")
(require "patterns.rkt")

<<shapes-base>>

<<sphere>>

<<plane>>

<<set-transformation>>

<<set-material>>

<<normal-at>>

<<pattern-at>>
#+END_SRC

** Patterns
#+BEGIN_SRC racket :noweb yes :tangle patterns.rkt
#lang typed/racket
(provide (except-out (all-defined-out) stripe gradient ring checker))
(require "tuples.rkt")
(require "color.rkt")
(require "matrix.rkt")

<<pattern-base>>

<<stripe>>

<<gradient>>

<<ring>>

<<checker>>
#+END_SRC
