#+STARTUP: show2levels
#+TITLE:     The Ray Tracer Challenge Notes
#+AUTHOR:    Calvin Xu
#+EMAIL:     calvinxu806@gmail.com

#+begin_quote
Admittedly, the explanations do tend toward imperative, procedural, and object-oriented languages, but the concepts and tests themselves are translatable to any environment you wish.
#+end_quote

My implementation will be in Typed Racket with unit tests in RackUnit. I will not be using OOP features in ~typed/racket/class~ as they are still "experimental". Usage of libraries will be minimal. Low-hanging optimization gains are done, but otherwise this is a learning project.

* DONE Tuples, Points, and Vectors
:PROPERTIES:
:ACTIVATED: [2022-07-30]
:END:
** /Refactor notes/
Originally all the numbers had ~Real~ type; I changed them all to ~Float~ after going into Optimization Coach in Dr. Racket and saw all the red areas screaming at me. However, this brings about a really irratating problem. Say you have a function that accepts a float, but you don't want to type the parameter with a decimal point all the time (i.e., ~3~ instead of ~3.~ or ~3.0~). Is there any way you can do that? Not any I could find! perhaps some macros could work, but I don't want to go that far. As far as I can tell, when you feed a integer like ~3~ into the Typed Racket interpreter, there's no way of telling it you actually want it to be a higher type or promoting in any way. If you try to cast, it thinks you are trying to cast an ~Integer~ to ~Float~...

In all the documentation I saw, people just type out the decimal point. So I guess I'll do that.

** DONE Tuples
:PROPERTIES:
:ACTIVATED: [2022-07-30]
:END:
Left-handed coordinate system (+x right, +y up, +z away)

Note that Typed Racket currently does not support ~field-option~ in structs meaning we can't set ~w~ to ~#:auto~ to prepopulate values.

Since the book hints at some runtime checks/tricks in the way it defined points and vectors, ~pt?~ and ~vec?~ are currently implemented this way.

The constructors that accept ~Real~ are written so that Typed Racket accepts numbers without the decimal point in the source code for the tests...

#+NAME: tuple-base
#+BEGIN_SRC racket :noweb yes
(struct tuple ([x : Float] [y : Float] [z : Float] [w : Float]) #:prefab #:type-name Tuple)
(struct point tuple () #:prefab #:type-name Point)
(struct vect tuple () #:prefab #:type-name Vector)

(: pt (->* (Float Float Float) (Float) Point))
(define (pt x y z [w 1.])
  (point x y z w))

(: pt? (-> Tuple Boolean))
(define (pt? t)
  (= (tuple-w t) 1.))

(: vec (->* (Float Float Float) (Float) Vector))
(define (vec x y z [w 0.])
  (vect x y z w))

(: vec? (-> Tuple Boolean))
(define (vec? t)
  (= (tuple-w t) 0.))
#+END_SRC

We can compare floats in ~rackunit~ with [[https://docs.racket-lang.org/rackunit/api.html#(def._((lib._rackunit/main..rkt)._check-~3d))][(check-= v1 v2 epsilon)]]:

#+begin_example
(check-= 1.0 1.01 0.02 "I work")
(check-= 1.0 1.01 0.005 "I fail")
#+end_example

In case I need it outside of tests:

#+NAME: f=
#+BEGIN_SRC racket :noweb yes
(: f= (-> Float Float Boolean))
(define (f= a b)
  (: EPSILON Float)
  (define EPSILON 0.00001)
  (< (abs (- a b)) EPSILON))
#+END_SRC

We should already be able to compare tuples for equality by making them ~#:prefab~. But then that isn't going to cut it. RackUnit's ~define-check~ seems broken in Typed Racket...I can't get a trivial example to work in the REPL and I can't find anyone's usage online. My own macro it is:

#+NAME: check-tuple=
#+BEGIN_SRC racket :noweb yes
(define-syntax-rule (check-tuple= t1 t2)
  (unless (and (f= (tuple-x t1) (tuple-x t2))
               (f= (tuple-y t1) (tuple-y t2))
               (f= (tuple-z t1) (tuple-z t2))
               (f= (tuple-w t1) (tuple-w t2)))
    (printf "Failure: tuples not equal ~v, ~v\n" t1 t2)))
#+END_SRC

** DONE Operations
:PROPERTIES:
:ACTIVATED: [2022-07-30]
:END:
*** Addition
- point + point -> ?
- point + vector -> point
- vector + point -> point
- vector + vector -> vector

#+NAME: tuple+
#+BEGIN_SRC racket :noweb yes
(: tuple+ (-> Tuple Tuple Tuple))
(define (tuple+ t1 t2)
  (let* ([xyzw : (List Float Float Float Float)
          (list (+ (tuple-x t1) (tuple-x t2))
                (+ (tuple-y t1) (tuple-y t2))
                (+ (tuple-z t1) (tuple-z t2))
                (+ (tuple-w t1) (tuple-w t2)))]
         [xyz : (List Float Float Float)
          (reverse (cdr (reverse xyzw)))])

    (cond
      [(and (pt? t1) (pt? t2) (error "Illegal operation: point + point" t1 t2))]
      [(or (and (pt? t1) (vec? t2)) (and (pt? t2) (vec? t1))) (apply pt xyz)]
      [(and (vec? t1) (vec? t2)) (apply vec xyz)]
      [else (apply tuple xyzw)])))
#+END_SRC

Let's make a variadic version:

#+BEGIN_SRC racket :noweb yes
(: tuples+ (-> Tuple * Tuple))
(define (tuples+ . tuples)
  (let loop ([sum (car tuples)] [args (cdr tuples)])
    (if (null? args) sum (loop (tuple+ sum (car args)) (cdr args)))))
#+END_SRC

...SICPish; or maybe try:

#+NAME: tuples+
#+BEGIN_SRC racket :noweb yes
(: tuples+ (-> Tuple * Tuple))
(define (tuples+ . tuples)
  (foldl tuple+ (tuple 0. 0. 0. 0.) tuples))
#+END_SRC

*** Subtraction
- point - point -> vector
- point - vector -> point
- vector - point -> ?
- vector - vector -> vector

#+NAME: tuple-
#+BEGIN_SRC racket :noweb yes
(: tuple- (-> Tuple Tuple Tuple))
(define (tuple- t1 t2)
  (let* ([xyzw : (List Float Float Float Float)
          (list (- (tuple-x t1) (tuple-x t2))
                (- (tuple-y t1) (tuple-y t2))
                (- (tuple-z t1) (tuple-z t2))
                (- (tuple-w t1) (tuple-w t2)))]
         [xyz : (List Float Float Float)
          (reverse (cdr (reverse xyzw)))])

    (cond
      [(and (vec? t1) (pt? t2) (error "Illegal operation: vector - point" t1 t2))]
      [(and (pt? t1) (pt? t2)) (apply vec xyz)]
      [(and (vec? t1) (vec? t2)) (apply vec xyz)]
      [(and (pt? t1) (vec? t2)) (apply pt xyz)]
      [else (apply tuple xyzw)])))
#+END_SRC

#+NAME: tuples-
#+BEGIN_SRC racket :noweb yes
(: tuples- (-> Tuple * Tuple))
(define (tuples- . tuples)
  ;; optimization when the list is known non-empty
  (if (null? tuples)
      (error "Illegal operation: no arguments provided")
      (foldl tuple+ (car tuples) (map -tuple (cdr tuples)))))
#+END_SRC

*** Negation
#+NAME: -tuple
#+BEGIN_SRC racket :noweb yes
(: -tuple (-> Tuple Tuple))
(define (-tuple t)
  (tuple (- (tuple-x t)) (- (tuple-y t)) (- (tuple-z t)) (- (tuple-w t))))
#+END_SRC

*** Scalar Multiplication and Division
#+NAME: tuple*
#+BEGIN_SRC racket :noweb yes
(: tuple* (-> Tuple Float Tuple))
(define (tuple* t s)
  (tuple (* (tuple-x t) s) (* (tuple-y t) s) (* (tuple-z t) s) (* (tuple-w t) s)))
#+END_SRC

#+NAME: tuple/
#+BEGIN_SRC racket :noweb yes
(: tuple/ (-> Tuple Float Tuple))
(define (tuple/ t s)
  (tuple (/ (tuple-x t) s) (/ (tuple-y t) s) (/ (tuple-z t) s) (/ (tuple-w t) s)))
#+END_SRC

*** Magnitude
#+NAME: mag
#+BEGIN_SRC racket :noweb yes
(: mag (-> Vector Float))
(define (mag v)
  (sqrt (+ (sqr (tuple-x v)) (sqr (tuple-y v)) (sqr (tuple-z v)))))
#+END_SRC

*** Normalization
#+NAME: norm
#+BEGIN_SRC racket :noweb yes
(: norm (-> Vector Vector))
(define (norm v)
  (let ([mag : Float (mag v)])
    (vec (/ (tuple-x v) mag) (/ (tuple-y v) mag) (/ (tuple-z v) mag))))
#+END_SRC

*** Dot Product
#+NAME: dot*
#+BEGIN_SRC racket :noweb yes
(: dot* (-> Vector Vector Float))
(define (dot* v1 v2)
  (+ (* (tuple-x v1) (tuple-x v2))
     (* (tuple-y v1) (tuple-y v2))
     (* (tuple-z v1) (tuple-z v2))
     (* (tuple-w v1) (tuple-w v2))))
#+END_SRC

*** Cross Product
#+NAME: cross*
#+BEGIN_SRC racket :noweb yes
(: cross* (-> Vector Vector Vector))
(define (cross* v1 v2)
  (vec (- (* (tuple-y v1) (tuple-z v2)) (* (tuple-z v1) (tuple-y v2)))
       (- (* (tuple-z v1) (tuple-x v2)) (* (tuple-x v1) (tuple-z v2)))
       (- (* (tuple-x v1) (tuple-y v2)) (* (tuple-y v1) (tuple-x v2)))))
#+END_SRC

** DONE Putting It Together
:PROPERTIES:
:ACTIVATED: [2022-07-31]
:END:
A fun playground:

#+BEGIN_SRC racket :noweb yes
<<tuples>>

(struct projectile ([position : Tuple] [velocity : Tuple]) #:prefab)
(struct environment ([gravity : Tuple] [wind : Tuple]) #:prefab)

(: tick (-> environment projectile projectile))
(define (tick env proj)
  (projectile (tuple+ (projectile-position proj) (projectile-velocity proj))
              (tuples+ (projectile-velocity proj) (environment-gravity env) (environment-wind env))))

(define p (projectile (pt 0. 1. 0.) (norm (vec 1. 1. 0.))))
(define e (environment (vec 0. -0.1 0.) (vec -0.01 0. 0.)))

(: iter (-> environment projectile Integer Any))
(define (iter env proj n)
  (if (or (> n 100) (<= (tuple-y (projectile-position proj)) 0))
      (print "Hit ground")
      (begin
        (printf "Tick #~v\n" n)
        (printf "Position: ~v\n" (projectile-position proj))
        (iter e (tick e proj) (+ 1 n)))))

(iter e p 0)
#+END_SRC

#+RESULTS:
#+begin_example
Tick #0
Position: '#s((point tuple 4) 0.0 1.0 0.0 1.0)
Tick #1
Position: '#s((point tuple 4) 0.7071067811865475 1.7071067811865475 0.0 1.0)
Tick #2
Position: '#s((point tuple 4) 1.404213562373095 2.314213562373095 0.0 1.0)
Tick #3
Position: '#s((point tuple 4) 2.0913203435596426 2.821320343559642 0.0 1.0)
Tick #4
Position: '#s((point tuple 4) 2.7684271247461902 3.2284271247461898 0.0 1.0)
Tick #5
Position: '#s((point tuple 4) 3.4355339059327377 3.5355339059327373 0.0 1.0)
Tick #6
Position: '#s((point tuple 4) 4.092640687119285 3.7426406871192848 0.0 1.0)
Tick #7
Position: '#s((point tuple 4) 4.739747468305833 3.849747468305832 0.0 1.0)
Tick #8
Position: '#s((point tuple 4) 5.37685424949238 3.85685424949238 0.0 1.0)
Tick #9
Position: '#s((point tuple 4) 6.003961030678928 3.7639610306789275 0.0 1.0)
Tick #10
Position: '#s((point tuple 4) 6.621067811865475 3.571067811865475 0.0 1.0)
Tick #11
Position: '#s((point tuple 4) 7.228174593052023 3.2781745930520225 0.0 1.0)
Tick #12
Position: '#s((point tuple 4) 7.82528137423857 2.88528137423857 0.0 1.0)
Tick #13
Position: '#s((point tuple 4) 8.412388155425118 2.3923881554251176 0.0 1.0)
Tick #14
Position: '#s((point tuple 4) 8.989494936611665 1.7994949366116653 0.0 1.0)
Tick #15
Position: '#s((point tuple 4) 9.556601717798213 1.1066017177982128 0.0 1.0)
Tick #16
Position: '#s((point tuple 4) 10.11370849898476 0.3137084989847604 0.0 1.0)
"Hit ground"
#+end_example

#+NAME: tuples
#+BEGIN_SRC racket :noweb yes :tangle tuples.rkt
#lang typed/racket

<<tuple-base>>

<<f=>>

<<tuple+>>

<<tuples+>>

<<tuple->>

<<tuples->>

<<-tuple>>

<<tuple*>>

<<tuple/>>

<<mag>>

<<norm>>

<<dot*>>

<<cross*>>

(provide (all-defined-out))
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/tuples-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt")

(define-syntax-rule (check-tuple= t1 t2)
  (unless (and (f= (tuple-x t1) (tuple-x t2))
               (f= (tuple-y t1) (tuple-y t2))
               (f= (tuple-z t1) (tuple-z t2))
               (f= (tuple-w t1) (tuple-w t2)))
    (printf "Failure: tuples not equal ~v, ~v\n" t1 t2)))

(define tuples-test
  (test-suite
   "Tuples, Points, and Vectors"
   (test-case "tuple-base"
              (define a (tuple 4.3 -4.2 3.1 1.0))
              (check-equal? (tuple-x a) 4.3)
              (check-equal? (tuple-y a) -4.2)
              (check-equal? (tuple-z a) 3.1)
              (check-equal? (tuple-w a) 1.0)
              (check-true (pt? a))
              (check-false (vec? a))
              (define b (tuple 4.3 -4.2 3.1 0.0))
              (check-equal? (tuple-x b) 4.3)
              (check-equal? (tuple-y b) -4.2)
              (check-equal? (tuple-z b) 3.1)
              (check-equal? (tuple-w b) 0.0)
              (check-false (pt? b))
              (check-true (vec? b))
              (define c (pt 4. -4. 3.))
              (check-tuple= c (tuple 4. -4. 3. 1.))
              (define d (vec 4. -4. 3.))
              (check-tuple= d (tuple 4. -4. 3. 0.)))
   (test-case "addition"
              (check-tuple= (tuple+ (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.)) (tuple 1. 1. 6. 1.))
              (check-tuple= (tuples+ (tuple 3. -2. 5. 1.)) (tuple 3. -2. 5. 1.))
              (check-tuple= (tuples+ (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.)) (tuple 1. 1. 6. 1.))
              (check-tuple= (tuples+ (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.) (tuple 1. 1. 1. 0.))
                            (tuple 2. 2. 7. 1.)))
   (test-case "subtraction"
              (check-tuple= (tuple- (pt 3. 2. 1.) (pt 5. 6. 7.)) (vec -2. -4. -6.))
              (check-tuple= (tuples- (tuple 3. -2. 5. 1.)) (tuple 3. -2. 5. 1.))
              (check-tuple= (tuples- (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.)) (tuple 5. -5. 4. 1.))
              (check-tuple= (tuples- (tuple 3. -2. 5. 1.) (tuple -2. 3. 1. 0.) (tuple 1. 1. 1. 1.))
                            (tuple 4. -6. 3. 0.)))
   (test-case "negation"
              (check-tuple= (tuple- (vec 0. 0. 0.) (vec 1. -2. 3.)) (vec -1. 2. -3.))
              (check-tuple= (-tuple (tuple 1. -2. 3. -4.)) (tuple -1. 2. -3. 4.)))
   (test-case "multiplication and division"
              (define a (tuple 1. -2. 3. -4.))
              (check-tuple= (tuple* a 3.5) (tuple 3.5 -7.0 10.5 -14.0))
              (check-tuple= (tuple* a 0.5) (tuple 0.5 -1.0 1.5 -2.0))
              (check-tuple= (tuple/ (tuple 1.0 -2. 3.0 -4.) 2.) (tuple 0.5 -1. 1.5 -2.)))
   (test-case "magnitude"
              (check-= (mag (vec 1. 0. 0.)) 1. 0.00001)
              (check-= (mag (vec 0. 1. 0.)) 1. 0.00001)
              (check-= (mag (vec 0. 0. 1.)) 1. 0.00001)
              (check-= (mag (vec 1. 2. 3.)) (sqrt 14.) 0.00001)
              (check-= (mag (vec -1. -2. -3.)) (sqrt 14.) 0.00001))
   (test-case "normalization"
              (check-tuple= (norm (vec 4. 0. 0.)) (vec 1. 0. 0.))
              (check-tuple= (norm (vec 1. 2. 3.)) (vec 0.26726 0.53452 0.80178)))
   (test-case "dot product" (check-= (dot* (vec 1. 2. 3.) (vec 2. 3. 4.)) 20. 0.00001))
   (test-case "cross product"
              (check-tuple= (cross* (vec 1. 2. 3.) (vec 2. 3. 4.)) (vec -1. 2. -1.))
              (check-tuple= (cross* (vec 2. 3. 4.) (vec 1. 2. 3.)) (vec 1. -2. 1.)))))

(run-tests tuples-test)
#+END_SRC

* DONE Drawing on a Canvas
:PROPERTIES:
:ACTIVATED: [2022-08-02]
:END:
** DONE Representing Colors
#+NAME: color-base
#+BEGIN_SRC racket :noweb yes
(struct color ([r : Float] [g : Float] [b : Float]) #:prefab #:type-name Color)

(: color->string (->* (Color) (Exact-Nonnegative-Integer) String))
(define (color->string color [max_color_val 255])
  (: scale (-> Float Integer))
  (define (scale frac)
    (exact-round (cast (* (max 0 (min 1.0 frac)) max_color_val) Float)))
  (string-append (number->string (scale (color-r color)))
                 " "
                 (number->string (scale (color-g color)))
                 " "
                 (number->string (scale (color-b color)))
                 " "))
#+END_SRC

#+NAME: check-color=
#+BEGIN_SRC racket :noweb yes
(define-syntax-rule (check-color= c1 c2)
  (unless (and (f= (color-r c1) (color-r c2))
               (f= (color-g c1) (color-g c2))
               (f= (color-b c1) (color-b c2)))
    (printf "Failure: colors not equal ~v, ~v\n" c1 c2)))
#+END_SRC

** DONE Implementing Color Operations
I'd rather not reuse the tuple implementations...
#+NAME: color-ops
#+BEGIN_SRC racket :noweb yes
(: color-op (-> (-> Float Float * Float) Color Color Color))
(define (color-op op c1 c2)
  (color (op (color-r c1) (color-r c2))
         (op (color-g c1) (color-g c2))
         (op (color-b c1) (color-b c2))))

(: color+ (-> Color Color Color))
(define (color+ c1 c2)
  (color-op + c1 c2))

(: color- (-> Color Color Color))
(define (color- c1 c2)
  (color-op - c1 c2))

(: color* (-> Color (U Color Float) Color))
(define (color* c arg)
  (color-op * c (if (color? arg) arg (color arg arg arg))))
#+END_SRC

** DONE Creating a Canvas
I got very tempted by  ~math/array~, but it might be more educational to build my own:

#+NAME: canvas-base
#+BEGIN_SRC racket :noweb yes
(struct _canvas
  ([width : Exact-Positive-Integer]
   [height : Exact-Positive-Integer]
   [pixels : (Mutable-Vectorof Color)]) #:prefab #:type-name Canvas)

(: canvas-width (-> Canvas Exact-Positive-Integer))
(define (canvas-width canvas)
  (_canvas-width canvas))

(: canvas-height (-> Canvas Exact-Positive-Integer))
(define (canvas-height canvas)
  (_canvas-height canvas))

(: canvas-pixels (-> Canvas (Mutable-Vectorof Color)))
(define (canvas-pixels canvas)
  (_canvas-pixels canvas))

(: canvas (-> Exact-Positive-Integer Exact-Positive-Integer Canvas))
(define (canvas width height)
  (_canvas width height (make-vector (* width height) (color 0. 0. 0.))))

(: pixel-at (-> Canvas Exact-Nonnegative-Integer Exact-Nonnegative-Integer Color))
(define (pixel-at canvas x y)
  (if (or (>= x (canvas-width canvas)) (>= y (canvas-height canvas)))
      (error "Illegal operation: access pixel out of bounds" x y)
      (vector-ref (canvas-pixels canvas) (+ (* y (canvas-width canvas)) x))))

(: set-pixel! (-> Canvas Exact-Nonnegative-Integer Exact-Nonnegative-Integer Color Void))
(define (set-pixel! canvas x y color)
  (if (or (>= x (canvas-width canvas)) (>= y (canvas-height canvas)))
      (error "Illegal operation: set pixel out of bounds" x y)
      (vector-set! (canvas-pixels canvas) (+ (* y (canvas-width canvas)) x) color)))
#+END_SRC

** DONE Saving a Canvas
PPM format specs: http://netpbm.sourceforge.net/doc/ppm.html

The following is very bad because I couldn't figure out a functional way of doing this.

#+NAME: canvas-save
#+BEGIN_SRC racket :noweb yes
(: serialize-canvas (->* (Canvas) (Exact-Nonnegative-Integer) String))
(define (serialize-canvas canvas [max_color_val 255])
  (define header
    (string-append "P3\n"
                   (number->string (canvas-width canvas))
                   " "
                   (number->string (canvas-height canvas))
                   "\n"
                   (number->string max_color_val)
                   "\n"))
  (define bitmap (vector-map (lambda ([x : Color]) (color->string x max_color_val)) (canvas-pixels canvas)))
  ;; color->string always adds whitespace at end
  ;; replace appropriate whitespaces with newlines
  (begin
    (let ([PIXELS_PER_ROW 6] [n (* (canvas-width canvas) (canvas-height canvas))])
      (for ([i (in-range n)])
        (when (or (= (add1 i) n) (= 0 (remainder (add1 i) PIXELS_PER_ROW)))
          (let ([curr (vector-ref bitmap i)])
            (vector-set! bitmap
                         i
                         (string-append (substring curr 0 (sub1 (string-length curr))) "\n"))))))
    (string-append header (string-append* (vector->list bitmap)))))

(: save-canvas (-> Canvas String Void))
(define (save-canvas canvas filename)
  (let ([out (open-output-file filename #:mode 'text #:exists 'replace)])
    (display (serialize-canvas canvas) out)
    (close-output-port out)))
#+END_SRC

#+BEGIN_SRC racket :noweb yes
#lang typed/racket
<<tuple-base>>
<<color-base>>
<<color-ops>>
<<canvas-base>>
<<canvas-save>>

(define c (canvas 5 3))
(set-pixel! c 0 0 (color 1.5 0 0))
(set-pixel! c 2 1 (color 0 0.5 0))
(set-pixel! c 4 2 (color -0.5 0 1))

(serialize-canvas c)
(save-canvas c "test.ppm")
#+END_SRC

#+RESULTS:
: "P3\n5 3\n255\n255 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 255\n"

** DONE Putting It Together
#+BEGIN_SRC racket :noweb yes
<<tuples>>
<<color-base>>
<<color-ops>>
<<canvas-base>>
<<canvas-save>>

(struct projectile ([position : Tuple] [velocity : Tuple]) #:prefab)
(struct environment ([gravity : Tuple] [wind : Tuple]) #:prefab)

(: tick (-> environment projectile projectile))
(define (tick env proj)
  (projectile (tuple+ (projectile-position proj) (projectile-velocity proj))
              (tuples+ (projectile-velocity proj) (environment-gravity env) (environment-wind env))))

(define p (projectile (pt 0. 1. 0.) (tuple* (norm (vec 1. 1.8 0.)) 11.25)))
(define e (environment (vec 0. -0.1 0.) (vec -0.01 0. 0.)))
(define c (canvas 900 550))

(: iter (-> environment projectile Canvas Integer Any))
(define (iter env proj canvas n)
  (if (or (> n 200) (<= (tuple-y (projectile-position proj)) 0))
      (begin
        (print "Hit ground")
        (save-canvas canvas "test.ppm"))
      (begin
        (printf "Tick #~v\n" n)
        (let ([position (projectile-position proj)]
              [flip (lambda ([y : Integer]) (- (canvas-height canvas) y))])
          (printf "Position: ~v\n" position)
          (set-pixel! canvas
                      (assert (max 0 (exact-round (tuple-x position))) nonnegative-integer?)
                      (assert (max 0 (flip (exact-round (tuple-y position)))) nonnegative-integer?)
                      (color 1. 0. 0.)))
        (iter e (tick e proj) canvas (+ 1 n)))))

(iter e p c 0)
#+END_SRC

#+NAME: canvas
#+BEGIN_SRC racket :noweb yes :tangle canvas.rkt
#lang typed/racket
(require "tuples.rkt")

<<color-base>>

<<check-color=>>

<<color-ops>>

<<canvas-base>>

<<canvas-save>>

(provide (except-out (all-defined-out) color-op))
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/canvas-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../canvas.rkt")

<<check-tuple=>>

(define canvas-test
  (test-suite
   "Drawing on a Canvas"
   (test-case "define color"
              (define c (color -0.5 0.4 1.7))
              (check-equal? (color-r c) -0.5)
              (check-equal? (color-g c) 0.4)
              (check-equal? (color-b c) 1.7))
   (test-case "add color"
              (define c1 (color 0.9 0.6 0.75))
              (define c2 (color 0.7 0.1 0.25))
              (check-color= (color+ c1 c2) (color 1.6 0.7 1.0)))
   (test-case "subtract color"
              (define c1 (color 0.9 0.6 0.75))
              (define c2 (color 0.7 0.1 0.25))
              (check-color= (color- c1 c2) (color 0.2 0.5 0.5)))
   (test-case "multiply color"
              (define c (color 0.2 0.3 0.4))
              (check-color= (color* c 2.) (color 0.4 0.6 0.8))
              (define c1 (color 1. 0.2 0.4))
              (define c2 (color 0.9 1. 0.1))
              (check-color= (color* c1 c2) (color 0.9 0.2 0.04)))
   (test-case "color to string"
              (define c (color 0.2 0.3 0.4))
              (check-equal? (color->string c) "51 76 102 "))
   (test-case "create and access canvas"
              (define c (canvas 10 20))
              (check-equal? (canvas-width c) 10)
              (check-equal? (canvas-height c) 20)
              (define red (color 1. 0. 0.))
              (set-pixel! c 2 3 red)
              (check-equal? (pixel-at c 2 3) red))
   (test-case
    "save canvas to ppm file"
    (define c (canvas 5 3))
    (set-pixel! c 0 0 (color 1.5 0. 0.))
    (set-pixel! c 2 1 (color 0. 0.5 0.))
    (set-pixel! c 4 2 (color -0.5 0. 1.))
    (check-equal?
     (serialize-canvas c)
     "P3\n5 3\n255\n255 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 255\n"))))

(run-tests canvas-test)
#+END_SRC

* NEXT Matrices
:PROPERTIES:
:ACTIVATED: [2022-08-05]
:END:
** DONE Creating a Matrix
It might be a good idea to use ~FlVector~, but I still want to try multidimensional vectors...

#+NAME: matrix-base
#+BEGIN_SRC racket :noweb yes
(struct matrix
  ([m : Exact-Nonnegative-Integer]
   [n : Exact-Nonnegative-Integer]
   [elements : (Immutable-Vectorof (Immutable-Vectorof Float))])
  #:prefab
  #:type-name Matrix)

(: mat (-> Exact-Nonnegative-Integer
           Exact-Nonnegative-Integer
           (Immutable-Vectorof (Immutable-Vectorof Float))
           Matrix))
(define (mat m n rows)
  (if (and (= m (vector-length rows))
           (andmap (lambda ([x : Integer]) (= x n)) (vector->list (vector-map vector-length rows))))
      (matrix m n rows)
      (error "Illegal operation: input not m by n 2D immutable vector" rows)))

(: mat-m (-> Matrix Exact-Nonnegative-Integer))
(define (mat-m mat)
  (matrix-m mat))

(: mat-n (-> Matrix Exact-Nonnegative-Integer))
(define (mat-n mat)
  (matrix-n mat))

(: mat-elems (-> Matrix (Immutable-Vectorof (Immutable-Vectorof Float))))
(define (mat-elems mat)
  (matrix-elements mat))

(: mat-entry (-> Matrix Exact-Nonnegative-Integer Exact-Nonnegative-Integer Float))
(define (mat-entry mat m n)
  (if (or (>= m (mat-m mat)) (>= n (mat-n mat)))
      (error "Illegal operation: access matrix element out of bounds")
      (vector-ref (vector-ref (mat-elems mat) m) n)))

(: mat-row (-> Matrix Exact-Nonnegative-Integer (Immutable-Vectorof Float)))
(define (mat-row mat m)
  (vector-ref (mat-elems mat) m))

(: mat-col (-> Matrix Exact-Nonnegative-Integer (Immutable-Vectorof Float)))
(define (mat-col mat n)
  (vector->immutable-vector (cast (for/vector #:length
                                    (mat-n mat)
                                    ([row (mat-elems mat)])
                                    (vector-ref row n))
                                  (Mutable-Vectorof Float))))

(: mat= (-> Matrix Matrix Boolean))
(define (mat= m1 m2)
  (: flatten-mat (-> Matrix (Listof Float)))
  (define (flatten-mat mat)
    (cast (flatten (vector->list (vector-map vector->list (mat-elems mat)))) (Listof Float)))
  (: compare (-> (Listof Float) (Listof Float) Boolean))
  (define (compare l1 l2)
    (cond
      ;; guarantee non-empty lists in 2nd case for optimization
      ;; lengths are checked equal beforehand
      [(or (null? l1) (null? l2)) #t]
      [(f= (car l1) (car l2)) (compare (cdr l1) (cdr l2))]
      [else #f]))
  (and (= (mat-m m1) (mat-m m2))
       (= (mat-n m1) (mat-n m2))
       (compare (flatten-mat m1) (flatten-mat m2))))
#+END_SRC

** TODO Multiplying Matrices
** TODO The Identity Matrix
** TODO Transposing Matrices
** TODO Inverting Matrices
** TODO Putting It Together
#+NAME: matrix
#+BEGIN_SRC racket :noweb yes :tangle matrix.rkt
#lang typed/racket
(require "tuples.rkt")

<<matrix-base>>

(provide (all-defined-out))
#+END_SRC

#+BEGIN_SRC racket :noweb yes :tangle tests/matrix-test.rkt
#lang typed/racket
(require typed/rackunit
         typed/rackunit/text-ui
         "../tuples.rkt"
         "../matrix.rkt")

<<check-tuple=>>

(define canvas-test
  (test-suite
   "Matrices"
   (test-case
    "define matrix"
    (define m (mat 4 4 #[#[1. 2. 3. 4.] #[5.5 6.5 7.5 8.5] #[9. 10. 11. 12.] #[13.5 14.5 15.5 16.5]]))
    (check-equal? (mat-entry m 0 0) 1.)
    (check-equal? (mat-entry m 0 3) 4.)
    (check-equal? (mat-entry m 1 0) 5.5)
    (check-equal? (mat-entry m 1 2) 7.5)
    (check-equal? (mat-entry m 2 2) 11.)
    (check-equal? (mat-entry m 3 0) 13.5)
    (check-equal? (mat-entry m 3 2) 15.5)
    (define m2 (mat 2 2 #[#[-3. 5.] #[1. -2.]]))
    (check-equal? (mat-entry m2 0 0) -3.)
    (check-equal? (mat-entry m2 0 1) 5.)
    (check-equal? (mat-entry m2 1 0) 1.)
    (check-equal? (mat-entry m2 1 1) -2.)
    (define m3 (mat 3 3 #[#[-3. 5. 0.] #[1. -2. -7.] #[0. 1. 1.]]))
    (check-equal? (mat-entry m3 0 0) -3.)
    (check-equal? (mat-entry m3 1 1) -2.)
    (check-equal? (mat-entry m3 2 2) 1.))
   (test-case "compare matrix"
              (define a (mat 4 4 #[#[1. 2. 3. 4.] #[5. 6. 7. 8.] #[9. 8. 7. 6.] #[5. 4. 3. 2.]]))
              (define b (mat 4 4 #[#[1. 2. 3. 4.] #[5. 6. 7. 8.] #[9. 8. 7. 6.] #[5. 4. 3. 2.]]))
              (check-true (mat= a b))
              (define c (mat 4 4 #[#[2. 3. 4. 5.] #[6. 7. 8. 9.] #[8. 7. 6. 5.] #[4. 3. 2. 1.]]))
              (check-false (mat= a c)))
   (test-case "get matrix row and column"
              (define a (mat 4 4 #[#[1. 2. 3. 4.] #[5. 6. 7. 8.] #[9. 8. 7. 6.] #[5. 4. 3. 2.]]))
              (check-equal? (mat-row a 2) #[9. 8. 7. 6.])
              (check-equal? (mat-col a 1) #[2. 6. 8. 4.]))
   ;; (test-case
   ;;  "multiply matrices"
   ;;  (define a (mat 4 4 #[#[1. 2. 3. 4.] #[5. 6. 7. 8.] #[9. 8. 7. 6.] #[5. 4. 3. 2.]]))
   ;;  (define b (mat 4 4 #[#[-2. 1. 2. 3.] #[3. 2. 1. -1.] #[4. 3. 6. 5.] #[1. 2. 7. 8.]]))
   ;;  (define c
   ;;    (mat 4 4 #[#[20. 22. 50. 48.] #[44. 54. 114. 108.] #[40. 58. 110. 102.] #[16. 26. 46. 42.]]))
   ;;  (check-true (mat= (mat* a b) c)))
   ;; (test-case "multiply matrix by vector (tuple)"
   ;;            (define a (mat 4 4 #[#[1. 2. 3. 4.] #[2. 4. 4. 2.] #[8. 6. 4. 1.] #[0. 0. 0. 1.]]))
   ;;            (define b (tuple 1. 2. 3. 1.))
   ;;            (check-tuple= (mat* a b) (tuple 18. 24. 33. 1.)))
   ))

(run-tests canvas-test)
#+END_SRC

* Matrix Transformations
** Translation
** Scaling
** Rotation
** Shearing
** Chaining Transformations
** Putting It Together
* Ray-Sphere Intersections
** Creating Rays
** Intersecting Rays with Spheres
** Tracking Intersections
** Identifying Hits
** Transforming Rays and Spheres
** Putting It Together
* Light and Shading
** Reflecting Vectors
** The Phong Reflection Model
** Putting It Together
* Making a Scene
** Building a World
** Defining a View Transformation
** Implementing a Camera
** Putting It Together
* Shadows
** Testing for Shadows
** Rendering Shadows
** Putting It Together
* Planes
** Refactoring Shapes
** Implementing a Plane
** Putting It Together
* Patterns
** Making a Striped Pattern
** Transforming Patterns
** Generalizing Patterns
** Making a Gradient Pattern
** Making a Ring Pattern
** Making a 3D Checker Pattern
** Putting It Together
* Reflection and Refraction
** Reflection
** Transparency and Refraction
** Fresnel Effect
** Putting It Together
* Cubes
** Intersecting a Ray with a Cube
** Finding the Normal on a Cube
** Putting It Together
* Cylinders
** Intersecting a Ray with a Cylinder
** Finding the Normal on a Cylinder
** Truncating Cylinders
** Capped Cylinders
** Cones
** Putting It Together
* Groups
** Implementing Groups
** Finding the Normal on a Child Object
** Using Bounding Boxes to Optimize Large Scenes
** Putting It Together
* Triangles
** Triangles
** Wavefront OBJ Files
** Smooth Triangles
** Smooth Triangles in OBJ Files
** Putting It Together
* Constructive Solid Geometry (CSG)
** Implementing CSG
** Coloring CSG Shapes
** Putting It Together
* Next Steps
** Area Lights and Soft Shadows
** Spotlights
** Focal Blur
** Motion Blur
** Anti-aliasing
** Texture Maps
** Normal Perturbation
** Torus Primitive
** Wrapping It Up
* Rendering the Cover Image
